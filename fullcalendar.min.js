/*!
 * FullCalendar v2.0.3
 * Docs & License: http://arshaw.com/fullcalendar/
 * (c) 2014 Adam Shaw, Sean Kenny
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery","moment"],a):a(jQuery,moment)}(function(a,b){function c(a,b){return b.longDateFormat("LT").replace(":mm","(:mm)").replace(/(\Wmm)$/,"($1)").replace(/\s*a$/i,"t")}function d(a,b){var c=b.longDateFormat("L");// for the format like "MM/DD/YYYY"
// strip the year off the edge, as well as other misc non-whitespace chars
return c=c.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g,""),a.isRTL?c+=" ddd":c="ddd "+c,c}
// function for adding/overriding defaults
function e(a){f(Fa,a)}
// Recursively combines option hash-objects.
// Better than `$.extend(true, ...)` because arrays are not traversed/copied.
//
// called like:
//     mergeOptions(target, obj1, obj2, ...)
//
function f(b){function c(c,d){a.isPlainObject(d)&&a.isPlainObject(b[c])&&!g(c)?
// merge into a new object to avoid destruction
b[c]=f({},b[c],d):void 0!==d&&(// only use values that are set and not undefined
b[c]=d)}for(var d=1;d<arguments.length;d++)a.each(arguments[d],c);return b}
// overcome sucky view-option-hash and option-merging behavior messing with options it shouldn't
function g(a){
// Any option that ends in "Time" or "Duration" is probably a Duration,
// and these will commonly be specified as plain objects, which we don't want to mess up.
return/(Time|Duration)$/.test(a)}function h(c,d){
// Language-data Internals
// -----------------------------------------------------------------------------------
// Apply overrides to the current language's data
// Returns moment's internal locale data. If doesn't exist, returns English.
// Works with moment-pre-2.8
function e(a){var c=b.localeData||b.langData;return c.call(b,a)||c.call(b,"en")}function g(a){ja?o()&&(
// mainly for the public API
v(),t(a)):h()}function h(){ka=ea.theme?"ui":"fc",c.addClass("fc"),ea.isRTL?c.addClass("fc-rtl"):c.addClass("fc-ltr"),ea.theme&&c.addClass("ui-widget"),ja=a("<div class='fc-content' />").prependTo(c),ha=new i(ca,ea),ia=ha.render(),ia&&c.prepend(ia),q(ea.defaultView),ea.handleWindowResize&&a(window).resize(y),
// needed for IE in a 0x0 iframe, b/c when it is resized, never triggers a windowResize
p()||k()}
// called when we know the calendar couldn't be rendered when it was initialized,
// but we think it's ready now
function k(){setTimeout(function(){// IE7 needs this so dimensions are calculated correctly
!la.start&&p()&&// !currentView.start makes sure this never happens more than once
s()},0)}function n(){la&&(_("viewDestroy",la,la,la.element),la.triggerEventDestroy()),a(window).unbind("resize",y),ea.droppable&&a(document).off("dragstart",aa).off("dragstop",ba),la.selectionManagerDestroy&&la.selectionManagerDestroy(),ha.destroy(),ja.remove(),c.removeClass("fc fc-ltr fc-rtl ui-widget")}function o(){return c.is(":visible")}function p(){return a("body").is(":visible")}
// View Rendering
// -----------------------------------------------------------------------------------
function q(a){la&&a==la.name||r(a)}function r(b){ua++,la&&(_("viewDestroy",la,la,la.element),L(),la.triggerEventDestroy(),// trigger 'eventDestroy' for each event
W(),la.element.remove(),ha.deactivateButton(la.name)),ha.activateButton(b),la=new Ja[b](a("<div class='fc-view fc-view-"+b+"' />").appendTo(ja),ca),s(),X(),ua--}function s(a){la.start&&// never rendered before
!a&&oa.isWithin(la.intervalStart,la.intervalEnd)||o()&&t(a)}function t(a){// assumes elementVisible
ua++,la.start&&(// already been rendered?
_("viewDestroy",la,la,la.element),L(),D()),W(),a&&(oa=la.incrementDate(oa,a)),la.render(oa.clone()),// the view's render method ONLY renders the skeleton, nothing else
w(),X(),(la.afterRender||B)(),I(),J(),_("viewRender",la,la,la.element),ua--,E()}
// Resizing
// -----------------------------------------------------------------------------------
function u(){o()&&(L(),D(),v(),w(),C())}function v(){// assumes elementVisible
na=ea.contentHeight?ea.contentHeight:ea.height?ea.height-(ia?ia.height():0)-x(ja):Math.round(ja.width()/Math.max(ea.aspectRatio,.5))}function w(){// assumes elementVisible
void 0===na&&v(),ua++,la.setHeight(na),la.setWidth(ja.width()),ua--,ma=c.outerWidth()}function y(a){if(!ua&&a.target===window)if(la.start){// view has already been rendered
var b=++ta;setTimeout(function(){// add a delay
b==ta&&!ua&&o()&&ma!=(ma=c.outerWidth())&&(ua++,// in case the windowResize callback changes the height
u(),la.trigger("windowResize",sa),ua--)},ea.windowResizeDelay)}else
// calendar must have been initialized in a 0x0 iframe that has just been resized
k()}/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
// TODO: going forward, most of this stuff should be directly handled by the view
function z(){// can be called as an API method
D(),F()}function A(a){// can be called as an API method
D(),C(a)}function C(a){// TODO: remove modifiedEventID hack
o()&&(la.renderEvents(va,a),// actually render the DOM elements
la.trigger("eventAfterAllRender"))}function D(){la.triggerEventDestroy(),// trigger 'eventDestroy' for each event
la.clearEvents(),// actually remove the DOM elements
la.clearEventData()}function E(){!ea.lazyFetching||qa(la.start,la.end)?F():C()}function F(){ra(la.start,la.end)}
// called when event data arrives
function G(a){va=a,C()}
// called when a single event's data has been changed
function H(a){A(a)}/* Header Updating
	-----------------------------------------------------------------------------*/
function I(){ha.updateTitle(la.title)}function J(){var a=ca.getNow();a.isWithin(la.intervalStart,la.intervalEnd)?ha.disableButton("today"):ha.enableButton("today")}/* Selection
	-----------------------------------------------------------------------------*/
function K(a,b){la.select(a,b)}function L(){// safe to be called before renderView
la&&la.unselect()}/* Date
	-----------------------------------------------------------------------------*/
function M(){s(-1)}function N(){s(1)}function O(){oa.add("years",-1),s()}function P(){oa.add("years",1),s()}function R(){oa=ca.getNow(),s()}function S(a){oa=ca.moment(a),s()}function U(a){oa.add(b.duration(a)),s()}function V(){return oa.clone()}/* Height "Freezing"
	-----------------------------------------------------------------------------*/
function W(){ja.css({width:"100%",height:ja.height(),overflow:"hidden"})}function X(){ja.css({width:"",height:"",overflow:""})}/* Misc
	-----------------------------------------------------------------------------*/
function Y(){return ca}function Z(){return la}function $(a,b){return void 0===b?ea[a]:void("height"!=a&&"contentHeight"!=a&&"aspectRatio"!=a||(ea[a]=b,u()))}function _(a,b){if(ea[a])return ea[a].apply(b||sa,Array.prototype.slice.call(arguments,2))}function aa(b,c){var d=b.target,e=a(d);if(!e.parents(".fc").length){// not already inside a calendar
var f=ea.dropAccept;(a.isFunction(f)?f.call(d,e):e.is(f))&&(pa=d,la.dragStart(pa,b,c))}}function ba(a,b){pa&&(la.dragStop(pa,a,b),pa=null)}var ca=this;
// Build options object
// -----------------------------------------------------------------------------------
// Precedence (lowest to highest): defaults, rtlDefaults, langOptions, instanceOptions
d=d||{};var da,ea=f({},Fa,d);
// determine language options
da=ea.lang in Ga?Ga[ea.lang]:Ga[Fa.lang],da&&(// if language options exist, rebuild...
ea=f({},Fa,da,d)),ea.isRTL&&(// is isRTL, rebuild...
ea=f({},Fa,Ha,da||{},d)),
// Exports
// -----------------------------------------------------------------------------------
ca.options=ea,ca.render=g,ca.destroy=n,ca.refetchEvents=z,ca.reportEvents=G,ca.reportEventChange=H,ca.rerenderEvents=A,ca.changeView=q,ca.select=K,ca.unselect=L,ca.prev=M,ca.next=N,ca.prevYear=O,ca.nextYear=P,ca.today=R,ca.gotoDate=S,ca.incrementDate=U,ca.getDate=V,ca.getCalendar=Y,ca.getView=Z,ca.option=$,ca.trigger=_;var fa=m(e(ea.lang));if(// make a cheap copy
ea.monthNames&&(fa._months=ea.monthNames),ea.monthNamesShort&&(fa._monthsShort=ea.monthNamesShort),ea.dayNames&&(fa._weekdays=ea.dayNames),ea.dayNamesShort&&(fa._weekdaysShort=ea.dayNamesShort),null!=ea.firstDay){var ga=m(fa._week);// _week: { dow: # }
ga.dow=ea.firstDay,fa._week=ga}
// Calendar-specific Date Utilities
// -----------------------------------------------------------------------------------
ca.defaultAllDayEventDuration=b.duration(ea.defaultAllDayEventDuration),ca.defaultTimedEventDuration=b.duration(ea.defaultTimedEventDuration),
// Builds a moment using the settings of the current calendar: timezone and language.
// Accepts anything the vanilla moment() constructor accepts.
ca.moment=function(){var a;
// Force the moment to be local, because fc.moment doesn't guarantee it.
// don't give ambiguously-timed moments a local zone
// moment 2.8 and above
// pre-moment-2.8
return"local"===ea.timezone?(a=Ia.moment.apply(null,arguments),a.hasTime()&&a.local()):a="UTC"===ea.timezone?Ia.moment.utc.apply(null,arguments):Ia.moment.parseZone.apply(null,arguments),"_locale"in a?a._locale=fa:a._lang=fa,a},
// Returns a boolean about whether or not the calendar knows how to calculate
// the timezone offset of arbitrary dates in the current timezone.
ca.getIsAmbigTimezone=function(){return"local"!==ea.timezone&&"UTC"!==ea.timezone},
// Returns a copy of the given date in the current timezone of it is ambiguously zoned.
// This will also give the date an unambiguous time.
ca.rezoneDate=function(a){return ca.moment(a.toArray())},
// Returns a moment for the current date, as defined by the client's computer,
// or overridden by the `now` option.
ca.getNow=function(){var a=ea.now;return"function"==typeof a&&(a=a()),ca.moment(a)},
// Calculates the week number for a moment according to the calendar's
// `weekNumberCalculation` setting.
ca.calculateWeekNumber=function(a){var b=ea.weekNumberCalculation;return"function"==typeof b?b(a):"local"===b?a.week():"ISO"===b.toUpperCase()?a.isoWeek():void 0},
// Get an event's normalized end date. If not present, calculate it from the defaults.
ca.getEventEnd=function(a){return a.end?a.end.clone():ca.getDefaultEventEnd(a.allDay,a.start)},
// Given an event's allDay status and start date, return swhat its fallback end date should be.
ca.getDefaultEventEnd=function(a,b){// TODO: rename to computeDefaultEventEnd
var c=b.clone();return a?c.stripTime().add(ca.defaultAllDayEventDuration):c.add(ca.defaultTimedEventDuration),ca.getIsAmbigTimezone()&&c.stripZone(),c},
// Date-formatting Utilities
// -----------------------------------------------------------------------------------
// Like the vanilla formatRange, but with calendar-specific settings applied.
ca.formatRange=function(a,b,c){
// a function that returns a formatStr // TODO: in future, precompute this
return"function"==typeof c&&(c=c.call(ca,ea,fa)),T(a,b,c,null,ea.isRTL)},
// Like the vanilla formatDate, but with calendar-specific settings applied.
ca.formatDate=function(a,b){
// a function that returns a formatStr // TODO: in future, precompute this
return"function"==typeof b&&(b=b.call(ca,ea,fa)),Q(a,b)},
// Imports
// -----------------------------------------------------------------------------------
j.call(ca,ea),l.call(ca,ea);var ha,ia,ja,ka,la,ma,na,oa,pa,qa=ca.isFetchNeeded,ra=ca.fetchEvents,sa=c[0],ta=0,ua=0,va=[];
// Main Rendering
// -----------------------------------------------------------------------------------
oa=null!=ea.defaultDate?ca.moment(ea.defaultDate):ca.getNow(),/* External Dragging
	------------------------------------------------------------------------*/
ea.droppable&&
// TODO: unbind on destroy
a(document).on("dragstart",aa).on("dragstop",ba)}function i(b,c){function d(){m=c.theme?"ui":"fc";var b=c.header;if(b)return n=a("<table class='fc-header' style='width:100%'/>").append(a("<tr/>").append(f("left")).append(f("center")).append(f("right")))}function e(){n.remove()}function f(d){var e=a("<td class='fc-header-"+d+"'/>"),f=c.header[d];return f&&a.each(f.split(" "),function(d){d>0&&e.append("<span class='fc-header-space'/>");var f;a.each(this.split(","),function(d,g){if("title"==g)e.append("<span class='fc-header-title'><h2>&nbsp;</h2></span>"),f&&f.addClass(m+"-corner-right"),f=null;else{var h;if(b[g]?h=b[g]:Ja[g]&&(h=function(){o.removeClass(m+"-state-hover"),// forget why
b.changeView(g)}),h){
// smartProperty allows different text per view button (ex: "Agenda Week" vs "Basic Week")
var i,j=E(c.themeButtonIcons,g),k=E(c.buttonIcons,g),l=E(c.defaultButtonText,g),n=E(c.buttonText,g);i=n?F(n):j&&c.theme?"<span class='ui-icon ui-icon-"+j+"'></span>":k&&!c.theme?"<span class='fc-icon fc-icon-"+k+"'></span>":F(l||g);var o=a("<span class='fc-button fc-button-"+g+" "+m+"-state-default'>"+i+"</span>").click(function(){o.hasClass(m+"-state-disabled")||h()}).mousedown(function(){o.not("."+m+"-state-active").not("."+m+"-state-disabled").addClass(m+"-state-down")}).mouseup(function(){o.removeClass(m+"-state-down")}).hover(function(){o.not("."+m+"-state-active").not("."+m+"-state-disabled").addClass(m+"-state-hover")},function(){o.removeClass(m+"-state-hover").removeClass(m+"-state-down")}).appendTo(e);H(o),f||o.addClass(m+"-corner-left"),f=o}}}),f&&f.addClass(m+"-corner-right")}),e}function g(a){n.find("h2").html(a)}function h(a){n.find("span.fc-button-"+a).addClass(m+"-state-active")}function i(a){n.find("span.fc-button-"+a).removeClass(m+"-state-active")}function j(a){n.find("span.fc-button-"+a).addClass(m+"-state-disabled")}function k(a){n.find("span.fc-button-"+a).removeClass(m+"-state-disabled")}var l=this;
// exports
l.render=d,l.destroy=e,l.updateTitle=g,l.activateButton=h,l.deactivateButton=i,l.disableButton=j,l.enableButton=k;
// locals
var m,n=a([])}function j(b){/* Fetching
	-----------------------------------------------------------------------------*/
function c(a,b){// nothing has been fetched yet?
// or, a part of the new range is outside of the old range? (after normalizing)
return!y||a.clone().stripZone()<y.clone().stripZone()||b.clone().stripZone()>z.clone().stripZone()}function d(a,b){y=a,z=b,J=[];var c=++G,d=F.length;H=d;for(var f=0;f<d;f++)e(F[f],c)}function e(b,c){f(b,function(d){var e,f,g=a.isArray(b.events);if(c==G){if(d)for(e=0;e<d.length;e++)f=d[e],
// event array sources have already been convert to Event Objects
g||(f=u(f,b)),f&&J.push(f);H--,H||C(J)}})}function f(c,d){var e,g,h=Ia.sourceFetchers;for(e=0;e<h.length;e++){if(g=h[e].call(x,// this, the Calendar object
c,y.clone(),z.clone(),b.timezone,d),g===!0)
// the fetcher is in charge. made its own async request
return;if("object"==typeof g)
// the fetcher returned a new source. process it
return void f(g,d)}var i=c.events;if(i)a.isFunction(i)?(s(),i.call(x,// this, the Calendar object
y.clone(),z.clone(),b.timezone,function(a){d(a),t()})):a.isArray(i)?d(i):d();else{var j=c.url;if(j){var k,l=c.success,m=c.error,n=c.complete;
// supplied as a function that returns a key/value object
k=a.isFunction(c.data)?c.data():c.data;
// use a copy of the custom data so we can modify the parameters
// and not affect the passed-in object.
var o=a.extend({},k||{}),p=L(c.startParam,b.startParam),q=L(c.endParam,b.endParam),r=L(c.timezoneParam,b.timezoneParam);p&&(o[p]=y.format()),q&&(o[q]=z.format()),b.timezone&&"local"!=b.timezone&&(o[r]=b.timezone),s(),a.ajax(a.extend({},Ka,c,{data:o,success:function(b){b=b||[];var c=K(l,this,arguments);a.isArray(c)&&(b=c),d(b)},error:function(){K(m,this,arguments),d()},complete:function(){K(n,this,arguments),t()}}))}else d()}}/* Sources
	-----------------------------------------------------------------------------*/
function g(a){var b=h(a);b&&(F.push(b),H++,e(b,G))}function h(b){// will return undefined if invalid source
var c,d,e=Ia.sourceNormalizers;if(a.isFunction(b)||a.isArray(b)?c={events:b}:"string"==typeof b?c={url:b}:"object"==typeof b&&(c=a.extend({},b),// shallow copy
"string"==typeof c.className&&(
// TODO: repeat code, same code for event classNames
c.className=c.className.split(/\s+/))),c){for(
// for array sources, we convert to standard Event Objects up front
a.isArray(c.events)&&(c.origArray=c.events,// for removeEventSource
c.events=a.map(c.events,function(a){return u(a,c)})),d=0;d<e.length;d++)e[d].call(x,c);return c}}function i(b){F=a.grep(F,function(a){return!j(a,b)}),
// remove all client events from that source
J=a.grep(J,function(a){return!j(a.source,b)}),C(J)}function j(a,b){return a&&b&&l(a)==l(b)}function l(a){// a normalized event source?
// get the primitive
return("object"==typeof a?a.origArray||a.url||a.events:null)||a}/* Manipulation
	-----------------------------------------------------------------------------*/
function m(a){a.start=x.moment(a.start),a.end&&(a.end=x.moment(a.end)),v(a),n(a),C(J)}function n(a){var b,c,d,e;for(b=0;b<J.length;b++)if(c=J[b],c._id==a._id&&c!==a)for(d=0;d<M.length;d++)e=M[d],void 0!==a[e]&&(c[e]=a[e])}function p(a,b){var c=u(a);c&&(c.source||(b&&(E.events.push(c),c.source=E),J.push(c)),C(J))}function q(b){var c,d;// inverse=true
// Remove events from array sources.
// This works because they have been converted to official Event Objects up front.
// (and as a result, event._id has been calculated).
for(null==b?// null or undefined. remove all events
b=function(){return!0}:a.isFunction(b)||(// an event ID
c=b+"",b=function(a){return a._id==c}),
// Purge event(s) from our local cache
J=a.grep(J,b,!0),d=0;d<F.length;d++)a.isArray(F[d].events)&&(F[d].events=a.grep(F[d].events,b,!0));C(J)}function r(b){// not null, not undefined. an event ID
return a.isFunction(b)?a.grep(J,b):null!=b?(b+="",a.grep(J,function(a){return a._id==b})):J}/* Loading State
	-----------------------------------------------------------------------------*/
function s(){I++||A("loading",null,!0,B())}function t(){--I||A("loading",null,!1,B())}/* Event Normalization
	-----------------------------------------------------------------------------*/
function u(c,d){// source may be undefined!
var e,f,g,h,i={};// "date" is an alias for "start"
if(b.eventDataTransform&&(c=b.eventDataTransform(c)),d&&d.eventDataTransform&&(c=d.eventDataTransform(c)),e=x.moment(c.start||c.date),e.isValid()&&(f=null,!c.end||(f=x.moment(c.end),f.isValid())))
// use the default
// normalize the date based on allDay
// neither date should have a time
// force a time/zone up the dates
// Copy all properties over to the resulting object.
// The special-case properties will be copied over afterwards.
// assumed to be an array
return g=c.allDay,void 0===g&&(h=L(d?d.allDayDefault:void 0,b.allDayDefault),g=void 0!==h?h:!(e.hasTime()||f&&f.hasTime())),g?(e.hasTime()&&e.stripTime(),f&&f.hasTime()&&f.stripTime()):(e.hasTime()||(e=x.rezoneDate(e)),f&&!f.hasTime()&&(f=x.rezoneDate(f))),a.extend(i,c),d&&(i.source=d),i._id=c._id||(void 0===c.id?"_fc"+La++:c.id+""),c.className?"string"==typeof c.className?i.className=c.className.split(/\s+/):i.className=c.className:i.className=[],i.resources?("number"==typeof i.resources&&(i.resources=[i.resources]),"string"==typeof i.resources&&(i.resources=i.resources.split(/\s+/))):i.resources=[],i.allDay=g,i.start=e,i.end=f,b.forceEventDuration&&!i.end&&(i.end=D(i)),k(i),i}/* Event Modification Math
	-----------------------------------------------------------------------------------------*/
// Modify the date(s) of an event and make this change propagate to all other events with
// the same ID (related repeating events).
//
// If `newStart`/`newEnd` are not specified, the "new" dates are assumed to be `event.start` and `event.end`.
// The "old" dates to be compare against are always `event._start` and `event._end` (set by EventManager).
//
// Returns an object with delta information and a function to undo all operations.
//
function v(a,b,c){var d,e,f,g,h=a._allDay,i=a._start,j=a._end,k=!1;
// if no new dates were passed in, compare against the event's existing dates
// NOTE: throughout this function, the initial values of `newStart` and `newEnd` are
// preserved. These values may be undefined.
// detect new allDay
// if value has changed, use it
// normalize the new dates based on allDay
// compute dateDelta
// if allDay has changed, always throw away the end
// new duration
// subtract old duration
// get events with this ID
return b||c||(b=a.start,c=a.end),d=a.allDay!=h?a.allDay:!(b||c).hasTime(),d&&(b&&(b=b.clone().stripTime()),c&&(c=c.clone().stripTime())),b&&(e=d?o(b,i.clone().stripTime()):o(b,i)),d!=h?k=!0:c&&(f=o(c||x.getDefaultEventEnd(d,b||i),b||i).subtract(o(j||x.getDefaultEventEnd(h,i),i))),g=w(r(a._id),k,d,e,f),{dateDelta:e,durationDelta:f,undo:g}}
// Modifies an array of events in the following ways (operations are in order):
// - clear the event's `end`
// - convert the event to allDay
// - add `dateDelta` to the start and end
// - add `durationDelta` to the event's duration
//
// Returns a function that can be called to undo all the operations.
//
function w(c,d,e,f,g){var h=x.getIsAmbigTimezone(),i=[];return a.each(c,function(a,c){var j=c._allDay,l=c._start,m=c._end,n=null!=e?e:j,o=l.clone(),p=!d&&m?m.clone():null;
// NOTE: this function is responsible for transforming `newStart` and `newEnd`,
// which were initialized to the OLD values first. `newEnd` may be null.
// normlize newStart/newEnd to be consistent with newAllDay
n?(o.stripTime(),p&&p.stripTime()):(o.hasTime()||(o=x.rezoneDate(o)),p&&!p.hasTime()&&(p=x.rezoneDate(p))),
// ensure we have an end date if necessary
p||!b.forceEventDuration&&!+g||(p=x.getDefaultEventEnd(n,o)),
// translate the dates
o.add(f),p&&p.add(f).add(g),
// if the dates have changed, and we know it is impossible to recompute the
// timezone offsets, strip the zone.
h&&(+f||+g)&&(o.stripZone(),p&&p.stripZone()),c.allDay=n,c.start=o,c.end=p,k(c),i.push(function(){c.allDay=j,c.start=l,c.end=m,k(c)})}),function(){for(var a=0;a<i.length;a++)i[a]()}}// assumed to be a calendar
var x=this;
// exports
x.isFetchNeeded=c,x.fetchEvents=d,x.addEventSource=g,x.removeEventSource=i,x.updateEvent=m,x.renderEvent=p,x.removeEvents=q,x.clientEvents=r,x.mutateEvent=v;
// imports
var y,z,A=x.trigger,B=x.getView,C=x.reportEvents,D=x.getEventEnd,E={events:[]},F=[E],G=0,H=0,I=0,J=[];a.each((b.events?[b.events]:[]).concat(b.eventSources||[]),function(a,b){var c=h(b);c&&F.push(c)});var M=["title","url","allDay","className","editable","color","backgroundColor","borderColor","textColor"]}
// updates the "backup" properties, which are preserved in order to compute diffs later on.
function k(a){a._allDay=a.allDay,a._start=a.start.clone(),a._end=a.end?a.end.clone():null}function l(b){
// add the resource sources
function c(b){l=[];var c;if(a.isFunction(b))
// is it a function?
c={resources:b},l.push(c),j=void 0;else if("string"==typeof b)
// is it a URL string?
c={url:b},l.push(c),j=void 0;else if("object"==typeof b&&null!=b){
// is it json object?
for(var d=0;d<b.length;d++){var e=b[d];f(e),c={resources:e},l.push(c)}j=void 0}}/**
   * ----------------------------------------------------------------
   * Fetch resources from source array
   * ----------------------------------------------------------------
   */
function d(c,d){if(
// if useCache is not defined, default to true
c="undefined"==typeof c||c,!c||void 0===j){
// do a fetch resource from source, rebuild cache
j=[];for(var f=l.length,g=0;g<f;g++){var h=e(l[g],d);j=j.concat(h)}}return a.isFunction(b.resourceFilter)?a.grep(j,b.resourceFilter):j}/**
   * ----------------------------------------------------------------
   * Fetch resources from each source.  If source is a function, call
   * the function and return the resource.  If source is a URL, get
   * the data via synchronized ajax call.  If the source is an
   * object, return it as is.
   * ----------------------------------------------------------------
   */
function e(c,d){var e=c.resources;if(e){if(a.isFunction(e))return e()}else{var f=c.url;if(f){var g={};if("object"==typeof d){var h=b.startParam,i=b.endParam;h&&(g[h]=Math.round(+d.intervalStart/1e3)),i&&(g[i]=Math.round(+d.intervalEnd/1e3))}a.ajax(a.extend({},Ka,c,{data:g,dataType:"json",cache:!1,success:function(a){a=a||[],e=a},error:function(){},async:!1}))}}return e}/**
   * ----------------------------------------------------------------
   * normalize the source object
   * ----------------------------------------------------------------
   */
function f(a){a.className?"string"==typeof a.className&&(a.className=a.className.split(/\s+/)):a.className=[];for(var b=Ia.sourceNormalizers,c=0;c<b.length;c++)b[c](a)}/* Event Modification Math
  -----------------------------------------------------------------------------------------*/
// Modify the date(s) of an event and make this change propagate to all other events with
// the same ID (related repeating events).
//
// If `newStart`/`newEnd` are not specified, the "new" dates are assumed to be `event.start` and `event.end`.
// The "old" dates to be compare against are always `event._start` and `event._end` (set by EventManager).
//
// Returns an object with delta information and a function to undo all operations.
//
function g(a,b,c,d){var e,f,g,j,k=a._allDay,l=a._start,m=a._end,n=!1;
// if no new dates were passed in, compare against the event's existing dates
// NOTE: throughout this function, the initial values of `newStart` and `newEnd` are
// preserved. These values may be undefined.
// detect new allDay
// if value has changed, use it
// normalize the new dates based on allDay
// compute dateDelta
// if allDay has changed, always throw away the end
// new duration
// subtract old duration
// get events with this ID
return c||d||(c=a.start,d=a.end),e=a.allDay!=k?a.allDay:!(c||d).hasTime(),e&&(c&&(c=c.clone().stripTime()),d&&(d=d.clone().stripTime())),c&&(f=e?o(c,l.clone().stripTime()):o(c,l)),e!=k?n=!0:d&&(g=o(d||i.getDefaultEventEnd(e,c||l),c||l).subtract(o(m||i.getDefaultEventEnd(k,l),l))),j=h(i.clientEvents(a._id),n,e,f,g,b),{dateDelta:f,durationDelta:g,undo:j}}
// Modifies an array of events in the following ways (operations are in order):
// - clear the event's `end`
// - convert the event to allDay
// - add `dateDelta` to the start and end
// - add `durationDelta` to the event's duration
//
// Returns a function that can be called to undo all the operations.
//
function h(c,d,e,f,g,h){var j=i.getIsAmbigTimezone(),l=[];return a.each(c,function(a,c){var m=c.resources,n=c._allDay,o=c._start,p=c._end,q=null!=e?e:n,r=o.clone(),s=!d&&p?p.clone():null;
// NOTE: this function is responsible for transforming `newStart` and `newEnd`,
// which were initialized to the OLD values first. `newEnd` may be null.
// normlize newStart/newEnd to be consistent with newAllDay
q?(r.stripTime(),s&&s.stripTime()):(r.hasTime()||(r=i.rezoneDate(r)),s&&!s.hasTime()&&(s=i.rezoneDate(s))),
// ensure we have an end date if necessary
s||!b.forceEventDuration&&!+g||(s=i.getDefaultEventEnd(q,r)),
// translate the dates
r.add(f),s&&s.add(f).add(g),
// if the dates have changed, and we know it is impossible to recompute the
// timezone offsets, strip the zone.
j&&(+f||+g)&&(r.stripZone(),s&&s.stripZone()),c.allDay=q,c.start=r,c.end=s,c.resources=h,k(c),l.push(function(){c.allDay=n,c.start=o,c.end=p,c.resources=m,k(c)})}),function(){for(var a=0;a<l.length;a++)l[a]()}}var i=this;
// exports
i.fetchResources=d,i.setResources=c,i.mutateResourceEvent=g;
// locals
var j,l=[];
// initialize the resources.
c(b.resources)}
// Create an object that has the given prototype.
// Just like Object.create
function m(a){var b=function(){};return b.prototype=a,new b}
// Copies specifically-owned (non-protoype) properties of `b` onto `a`.
// FYI, $.extend would copy *all* properties of `b` onto `a`.
function n(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c])}
// diffs the two moments into a Duration where full-days are recorded first,
// then the remaining time.
function o(a,c){return b.duration({days:a.clone().stripTime().diff(c.clone().stripTime(),"days"),ms:a.time()-c.time()})}function p(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}/* Event Element Binding
-----------------------------------------------------------------------------*/
function q(b,c,d){b.unbind("mouseover").mouseover(function(b){for(var e,f,g,h=b.target;h!=this;)e=h,h=h.parentNode;void 0!==(f=e._fci)&&(e._fci=void 0,g=c[f],d(g.event,g.element,g),a(b.target).trigger(b)),b.stopPropagation()})}/* Element Dimensions
-----------------------------------------------------------------------------*/
function r(b,c,d){for(var e,f=0;f<b.length;f++)e=a(b[f]),e.width(Math.max(0,c-t(e,d)))}function s(b,c,d){for(var e,f=0;f<b.length;f++)e=a(b[f]),e.height(Math.max(0,c-x(e,d)))}function t(a,b){return u(a)+w(a)+(b?v(a):0)}function u(b){return(parseFloat(a.css(b[0],"paddingLeft",!0))||0)+(parseFloat(a.css(b[0],"paddingRight",!0))||0)}function v(b){return(parseFloat(a.css(b[0],"marginLeft",!0))||0)+(parseFloat(a.css(b[0],"marginRight",!0))||0)}function w(b){return(parseFloat(a.css(b[0],"borderLeftWidth",!0))||0)+(parseFloat(a.css(b[0],"borderRightWidth",!0))||0)}function x(a,b){return y(a)+A(a)+(b?z(a):0)}function y(b){return(parseFloat(a.css(b[0],"paddingTop",!0))||0)+(parseFloat(a.css(b[0],"paddingBottom",!0))||0)}function z(b){return(parseFloat(a.css(b[0],"marginTop",!0))||0)+(parseFloat(a.css(b[0],"marginBottom",!0))||0)}function A(b){return(parseFloat(a.css(b[0],"borderTopWidth",!0))||0)+(parseFloat(a.css(b[0],"borderBottomWidth",!0))||0)}/* Misc Utils
-----------------------------------------------------------------------------*/
//TODO: arraySlice
//TODO: isFunction, grep ?
function B(){}function C(a,b){// works with moments too
return a-b}function D(a){return Math.max.apply(Math,a)}function E(a,b){if(// get a camel-cased/namespaced property of an object
a=a||{},void 0!==a[b])return a[b];for(var c,d=b.split(/(?=[A-Z])/),e=d.length-1;e>=0;e--)if(c=a[d[e].toLowerCase()],void 0!==c)return c;return a["default"]}function F(a){return(a+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/'/g,"&#039;").replace(/"/g,"&quot;").replace(/\n/g,"<br />")}function G(a){return a.replace(/&.*?;/g,"")}function H(a){a.attr("unselectable","on").css("MozUserSelect","none").bind("selectstart.ui",function(){return!1})}/*
function enableTextSelection(element) {
	element
		.attr('unselectable', 'off')
		.css('MozUserSelect', '')
		.unbind('selectstart.ui');
}
*/
function I(a){// TODO: use CSS selectors instead
a.children().removeClass("fc-first fc-last").filter(":first-child").addClass("fc-first").end().filter(":last-child").addClass("fc-last")}function J(a,b){var c=a.source||{},d=a.color,e=c.color,f=b("eventColor"),g=a.backgroundColor||d||c.backgroundColor||e||b("eventBackgroundColor")||f,h=a.borderColor||d||c.borderColor||e||b("eventBorderColor")||f,i=a.textColor||c.textColor||b("eventTextColor"),j=[];return g&&j.push("background-color:"+g),h&&j.push("border-color:"+h),i&&j.push("color:"+i),j.join(";")}function K(b,c,d){if(a.isFunction(b)&&(b=[b]),b){var e,f;for(e=0;e<b.length;e++)f=b[e].apply(c,d)||f;return f}}function L(){for(var a=0;a<arguments.length;a++)if(void 0!==arguments[a])return arguments[a]}
// Builds an FCMoment from args. When given an existing moment, it clones. When given a native
// Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function M(c,d,e){var f,g,h,i,j=c[0],k=1==c.length&&"string"==typeof j;// an object with fields for the new FCMoment object
// clone it
// the ambig properties have not been preserved in the clone, so reassign them
// "parsing" is required
// accept strings like '2014-05', but convert to the first of the month
// for when we pass it on to moment's constructor
// no time part?
// arrays have no timezone information, so assume ambiguous zone
// otherwise, probably a string with a format
// let's record the inputted zone somehow
return b.isMoment(j)?(i=b.apply(null,c),j._ambigTime&&(i._ambigTime=!0),j._ambigZone&&(i._ambigZone=!0)):p(j)||void 0===j?i=b.apply(null,c):(f=!1,g=!1,k?Na.test(j)?(j+="-01",c=[j],f=!0,g=!0):(h=Oa.exec(j))&&(f=!h[5],g=!0):a.isArray(j)&&(g=!0),i=d?b.utc.apply(b,c):b.apply(null,c),f?(i._ambigTime=!0,i._ambigZone=!0):e&&(g?i._ambigZone=!0:k&&i.zone(j))),new N(i)}
// Our subclass of Moment.
// Accepts an object with the internal Moment properties that should be copied over to
// `this` object (most likely another Moment object). The values in this data must not
// be referenced by anything else (two moments sharing a Date object for example).
function N(a){n(this,a)}
// Misc Internals
// -------------------------------------------------------------------------------------------------
// given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.
// for example, of one moment has ambig time, but not others, all moments will have their time stripped.
function O(a){var b,c=[],d=!1,e=!1;for(b=0;b<a.length;b++)c.push(Ia.moment(a[b])),d=d||c[b]._ambigTime,e=e||c[b]._ambigZone;for(b=0;b<c.length;b++)d?c[b].stripTime():e&&c[b].stripZone();return c}
// Single Date Formatting
// -------------------------------------------------------------------------------------------------
// call this if you want Moment's original format method to be used
function P(a,c){return b.fn.format.call(a,c)}
// Formats `date` with a Moment formatting string, but allow our non-zero areas and
// additional token.
function Q(a,b){return R(a,W(b))}function R(a,b){var c,d="";for(c=0;c<b.length;c++)d+=S(a,b[c]);return d}function S(a,b){var c,d;// a token, like "YYYY"
// a grouping of other chunks that must be non-zero
return"string"==typeof b?b:(c=b.token)?Pa[c]?Pa[c](a):P(a,c):b.maybe&&(d=R(a,b.maybe),d.match(/[1-9]/))?d:""}
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
// Using a formatting string meant for a single date, generate a range string, like
// "Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
// If the dates are the same as far as the format string is concerned, just return a single
// rendering of one date, without any separator.
function T(a,b,c,d,e){var f;// works with moment-pre-2.8
// Expand localized format strings, like "LL" -> "MMMM D YYYY"
// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
// or non-zero areas in Moment's localized format strings.
return a=Ia.moment.parseZone(a),b=Ia.moment.parseZone(b),f=(a.localeData||a.lang).call(a),c=f.longDateFormat(c)||c,d=d||" - ",U(a,b,W(c),d,e)}// expose
function U(a,b,c,d,e){var f,g,h,i,j="",k="",l="",m="",n="";
// Start at the leftmost side of the formatting string and continue until you hit a token
// that is not the same between dates.
for(g=0;g<c.length&&(f=V(a,b,c[g]),f!==!1);g++)j+=f;
// Similarly, start at the rightmost side of the formatting string and move left
for(h=c.length-1;h>g&&(f=V(a,b,c[h]),f!==!1);h--)k=f+k;
// The area in the middle is different for both of the dates.
// Collect them distinctly so we can jam them together later.
for(i=g;i<=h;i++)l+=S(a,c[i]),m+=S(b,c[i]);return(l||m)&&(n=e?m+d+l:l+d+m),j+n+k}
// TODO: week maybe?
// Given a formatting chunk, and given that both dates are similar in the regard the
// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.
function V(a,b,c){var d,e;return"string"==typeof c?c:!!((d=c.token)&&(e=Qa[d.charAt(0)],e&&a.isSame(b,e)))&&P(a,d)}function W(a){return a in Ra?Ra[a]:Ra[a]=X(a)}
// Break the formatting string into an array of chunks
function X(a){for(var b,c=[],d=/\[([^\]]*)\]|\(([^\)]*)\)|(LT|(\w)\4*o?)|([^\w\[\(]+)/g;b=d.exec(a);)b[1]?// a literal string inside [ ... ]
c.push(b[1]):b[2]?// non-zero formatting inside ( ... )
c.push({maybe:X(b[2])}):b[3]?// a formatting token
c.push({token:b[3]}):b[5]&&// an unenclosed literal string
c.push(b[5]);return c}function Y(a,b){function c(a,b){return a.clone().stripTime().add("months",b).startOf("month")}function d(a){e.intervalStart=a.clone().stripTime().startOf("month"),e.intervalEnd=e.intervalStart.clone().add("months",1),e.start=e.intervalStart.clone(),e.start=e.skipHiddenDays(e.start),// move past the first week if no visible days
e.start.startOf("week"),e.start=e.skipHiddenDays(e.start),// move past the first invisible days of the week
e.end=e.intervalEnd.clone(),e.end=e.skipHiddenDays(e.end,-1,!0),// move in from the last week if no visible days
e.end.add((7-e.end.weekday())%7,"days"),// move to end of week if not already
e.end=e.skipHiddenDays(e.end,-1,!0);// move in from the last invisible days of the week
var c=Math.ceil(// need to ceil in case there are hidden days
e.end.diff(e.start,"weeks",!0));"fixed"==e.opt("weekMode")&&(e.end.add("weeks",6-c),c=6),e.title=b.formatDate(e.intervalStart,e.opt("titleFormat")),e.renderBasic(c,e.getCellsPerWeek(),!0)}var e=this;
// exports
e.incrementDate=c,e.render=d,
// imports
_.call(e,a,b,"month")}function Z(a,b){function c(a,b){return a.clone().stripTime().add("weeks",b).startOf("week")}function d(a){e.intervalStart=a.clone().stripTime().startOf("week"),e.intervalEnd=e.intervalStart.clone().add("weeks",1),e.start=e.skipHiddenDays(e.intervalStart),e.end=e.skipHiddenDays(e.intervalEnd,-1,!0),e.title=b.formatRange(e.start,e.end.clone().subtract(1),// make inclusive by subtracting 1 ms
e.opt("titleFormat")," — "),e.renderBasic(1,e.getCellsPerWeek(),!1)}// TODO: do a WeekView mixin
var e=this;
// exports
e.incrementDate=c,e.render=d,
// imports
_.call(e,a,b,"basicWeek")}function $(a,b){function c(a,b){var c=a.clone().stripTime().add(b,"days");return c=e.skipHiddenDays(c,b<0?-1:1)}function d(a){e.start=e.intervalStart=a.clone().stripTime(),e.end=e.intervalEnd=e.start.clone().add(1,"days"),e.title=b.formatDate(e.start,e.opt("titleFormat")),e.renderBasic(1,1,!1)}// TODO: make a DayView mixin
var e=this;
// exports
e.incrementDate=c,e.render=d,
// imports
_.call(e,a,b,"basicDay")}function _(b,c,d){function e(a,b,c){X=a,Y=b,Z=c,f(),M||g(),h()}function f(){da=ga("theme")?"ui":"fc",ea=ga("columnFormat"),fa=ga("weekNumbers")}function g(){S=a("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(b)}function h(){var c=i();J&&J.remove(),J=a(c).appendTo(b),K=J.find("thead"),L=K.find(".fc-day-header"),M=J.find("tbody"),N=M.find("tr"),O=M.find(".fc-day"),P=N.find("td:first-child"),Q=N.eq(0).find(".fc-day > div"),R=N.eq(0).find(".fc-day-content > div"),I(K.add(K.find("tr"))),// marks first+last tr/th's
I(N),// marks first+last td's
N.eq(0).addClass("fc-first"),N.filter(":last").addClass("fc-last"),O.each(function(b,c){var d=la(Math.floor(b/Y),b%Y);ha("dayRender",G,d,a(c))}),o(O)}/* HTML Building
	-----------------------------------------------------------*/
function i(){var a="<table class='fc-border-separate' style='width:100%' cellspacing='0'>"+j()+k()+"</table>";return a}function j(){var a,b,c=da+"-widget-header",d="";for(d+="<thead><tr>",fa&&(d+="<th class='fc-week-number "+c+"'>"+F(ga("weekNumberTitle"))+"</th>"),a=0;a<Y;a++)b=la(0,a),d+="<th class='fc-day-header fc-"+Ma[b.day()]+" "+c+"'>"+F(oa(b,ea))+"</th>";return d+="</tr></thead>"}function k(){var a,b,c,d=da+"-widget-content",e="";for(e+="<tbody>",a=0;a<X;a++){for(e+="<tr class='fc-week'>",fa&&(c=la(a,0),e+="<td class='fc-week-number "+d+"'><div>"+F(pa(c))+"</div></td>"),b=0;b<Y;b++)c=la(a,b),e+=l(c);e+="</tr>"}return e+="</tbody>"}function l(a){// date assumed to have stripped time
var b=G.intervalStart.month(),d=c.getNow().stripTime(),e="",f=da+"-widget-content",g=["fc-day","fc-"+Ma[a.day()],f];return a.month()!=b&&g.push("fc-other-month"),a.isSame(d,"day")?g.push("fc-today",da+"-state-highlight"):a<d?g.push("fc-past"):g.push("fc-future"),e+="<td class='"+g.join(" ")+"' data-date='"+a.format()+"'><div>",Z&&(e+="<div class='fc-day-number'>"+a.date()+"</div>"),e+="<div class='fc-day-content'><div style='position:relative'>&nbsp;</div></div></div></td>"}/* Dimensions
	-----------------------------------------------------------*/
function m(b){U=b;var c,d,e,f=Math.max(U-K.height(),0);"variable"==ga("weekMode")?c=d=Math.floor(f/(1==X?2:6)):(c=Math.floor(f/X),d=f-c*(X-1)),P.each(function(b,f){b<X&&(e=a(f),e.find("> div").css("min-height",(b==X-1?d:c)-x(e)))})}function n(a){T=a,ba.clear(),ca.clear(),W=0,fa&&(W=K.find("th.fc-week-number").outerWidth()),V=Math.floor((T-W)/Y),r(L.slice(0,-1),V)}/* Day clicking and binding
	-----------------------------------------------------------*/
function o(a){a.click(p).mousedown(ka)}function p(b){if(!ga("selectable")){// if selectable, SelectionManager will worry about dayClick
var d=c.moment(a(this).data("date"));ha("dayClick",this,d,b)}}/* Semi-transparent Overlay Helpers
	------------------------------------------------------*/
// TODO: should be consolidated with AgendaView's methods
function q(a,b,c){// overlayEnd is exclusive
c&&$.build();for(var d=na(a,b),e=0;e<d.length;e++){var f=d[e];o(s(f.row,f.leftCol,f.row,f.rightCol))}}function s(a,c,d,e){// row1,col1 is inclusive
var f=$.rect(a,c,d,e,b);return ia(f,b)}/* Selection
	-----------------------------------------------------------------------*/
function t(a){return a.clone().stripTime().add(1,"days")}function u(a,b){// end is exclusive
q(a,b,!0)}function v(){ja()}function w(a,b){var c=ma(a),d=O[c.row*Y+c.col];ha("dayClick",d,a,b)}/* External Dragging
	-----------------------------------------------------------------------*/
function y(a,b,d){_.start(function(a){if(ja(),a){var b=la(a),d=b.clone().add(c.defaultAllDayEventDuration);q(b,d)}},b)}function z(a,b,c){var d=_.stop();ja(),d&&ha("drop",a,la(d),b,c)}function A(a){return ba.left(a)}function B(a){return ba.right(a)}function C(a){return ca.left(a)}function D(a){return ca.right(a)}function E(a){return N.eq(a)}var G=this;
// exports
G.renderBasic=e,G.setHeight=m,G.setWidth=n,G.renderDayOverlay=q,G.defaultSelectionEnd=t,G.renderSelection=u,G.clearSelection=v,G.reportDayClick=w,// for selection (kinda hacky)
G.dragStart=y,G.dragStop=z,G.getHoverListener=function(){return _},G.colLeft=A,G.colRight=B,G.colContentLeft=C,G.colContentRight=D,G.getIsCellAllDay=function(){return!0},G.allDayRow=E,G.getRowCnt=function(){return X},G.getColCnt=function(){return Y},G.getColWidth=function(){return V},G.getDaySegmentContainer=function(){return S},
// imports
ua.call(G,b,c,d),Aa.call(G),za.call(G),aa.call(G);var J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,_,ba,ca,da,ea,fa,ga=G.opt,ha=G.trigger,ia=G.renderOverlay,ja=G.clearOverlays,ka=G.daySelectionMousedown,la=G.cellToDate,ma=G.dateToCell,na=G.rangeToSegments,oa=c.formatDate,pa=c.calculateWeekNumber;/* Rendering
	------------------------------------------------------------*/
H(b.addClass("fc-grid")),/* Utilities
	--------------------------------------------------------*/
$=new Ba(function(b,c){var d,e,f;L.each(function(b,g){d=a(g),e=d.offset().left,b&&(f[1]=e),f=[e],c[b]=f}),f[1]=e+d.outerWidth(),N.each(function(c,g){c<X&&(d=a(g),e=d.offset().top,c&&(f[1]=e),f=[e],b[c]=f)}),f[1]=e+d.outerHeight()}),_=new Ca($),ba=new Ea(function(a){return Q.eq(a)}),ca=new Ea(function(a){return R.eq(a)})}function aa(){function a(a,b){c.renderDayEvents(a,b)}function b(){c.getDaySegmentContainer().empty()}var c=this;
// exports
c.renderEvents=a,c.clearEvents=b,
// imports
va.call(c)}function ba(a,b){function c(a,b){return a.clone().stripTime().add("weeks",b).startOf("week")}function d(a){e.intervalStart=a.clone().stripTime().startOf("week"),e.intervalEnd=e.intervalStart.clone().add("weeks",1),e.start=e.skipHiddenDays(e.intervalStart),e.end=e.skipHiddenDays(e.intervalEnd,-1,!0),e.title=b.formatRange(e.start,e.end.clone().subtract(1),// make inclusive by subtracting 1 ms
e.opt("titleFormat")," — "),e.renderAgenda(e.getCellsPerWeek())}// TODO: do a WeekView mixin
var e=this;
// exports
e.incrementDate=c,e.render=d,
// imports
fa.call(e,a,b,"agendaWeek")}function ca(a,b){function c(a,b){var c=a.clone().stripTime().add(b,"days");return c=e.skipHiddenDays(c,b<0?-1:1)}function d(a){e.start=e.intervalStart=a.clone().stripTime(),e.end=e.intervalEnd=e.start.clone().add(1,"days"),e.title=b.formatDate(e.start,e.opt("titleFormat")),e.renderAgenda(1)}// TODO: make a DayView mixin
var e=this;
// exports
e.incrementDate=c,e.render=d,
// imports
fa.call(e,a,b,"agendaDay")}function da(a,b){return b.longDateFormat("LT").replace(":mm","(:mm)").replace(/(\Wmm)$/,"($1)").replace(/\s*a$/i,"a")}function ea(a,b){return b.longDateFormat("LT").replace(/\s*a$/i,"")}
// TODO: make it work in quirks mode (event corners, all-day height)
// TODO: test liquid width, especially in IE6
function fa(c,d,e){function f(a){wa=a,g(),U?i():// first time rendering?
h()}function g(){Ha=Na("theme")?"ui":"fc",Ia=Na("isRTL"),La=Na("columnFormat"),Ja=b.duration(Na("minTime")),Ka=b.duration(Na("maxTime")),qa=b.duration(Na("slotDuration")),sa=Na("snapDuration"),sa=sa?b.duration(sa):qa}/* Build DOM
	-----------------------------------------------------------------------*/
function h(){var d,e,f,g,h=Ha+"-widget-header",j=Ha+"-widget-content",k=qa.asMinutes()%15===0;for(i(),ba=a("<div style='position:absolute;z-index:2;left:0;width:100%'/>").appendTo(c),Na("allDaySlot")?(ca=a("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(ba),d="<table style='width:100%' class='fc-agenda-allday' cellspacing='0'><tr><th class='"+h+" fc-agenda-axis'>"+(Na("allDayHTML")||F(Na("allDayText")))+"</th><td><div class='fc-day-content'><div style='position:relative'/></div></td><th class='"+h+" fc-agenda-gutter'>&nbsp;</th></tr></table>",da=a(d).appendTo(ba),ea=da.find("tr"),q(ea.find("td")),ba.append("<div class='fc-agenda-divider "+h+"'><div class='fc-agenda-divider-inner'/></div>")):ca=a([]),fa=a("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>").appendTo(ba),ha=a("<div style='position:relative;width:100%;overflow:hidden'/>").appendTo(fa),ia=a("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(ha),d="<table class='fc-agenda-slots' style='width:100%' cellspacing='0'><tbody>",e=b.duration(+Ja),// i wish there was .clone() for durations
xa=0;e<Ka;)f=T.start.clone().time(e),// will be in UTC but that's good. to avoid DST issues
g=f.minutes(),d+="<tr class='fc-slot"+xa+" "+(g?"fc-minor":"")+"'><th class='fc-agenda-axis "+h+"'>"+(k&&g?"&nbsp;":F(Ya(f,Na("axisFormat"))))+"</th><td class='"+j+"'><div style='position:relative'>&nbsp;</div></td></tr>",e.add(qa),xa++;d+="</tbody></table>",ja=a(d).appendTo(ha),t(ja.find("td"))}/* Build Day Table
	-----------------------------------------------------------------------*/
function i(){var b=j();U&&U.remove(),U=a(b).appendTo(c),V=U.find("thead"),W=V.find("th").slice(1,-1),// exclude gutter
X=U.find("tbody"),Y=X.find("td").slice(0,-1),// exclude gutter
Z=Y.find("> div"),$=Y.find(".fc-day-content > div"),_=Y.eq(0),aa=Z.eq(0),I(V.add(V.find("tr"))),I(X.add(X.find("tr")))}function j(){var a="<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>"+k()+l()+"</table>";return a}function k(){var a,b,c,d=Ha+"-widget-header",e="";for(e+="<thead><tr>",Na("weekNumbers")?(a=Va(0,0),b=Za(a),Ia?b+=Na("weekNumberTitle"):b=Na("weekNumberTitle")+b,e+="<th class='fc-agenda-axis fc-week-number "+d+"'>"+F(b)+"</th>"):e+="<th class='fc-agenda-axis "+d+"'>&nbsp;</th>",c=0;c<wa;c++)a=Va(0,c),e+="<th class='fc-"+Ma[a.day()]+" fc-col"+c+" "+d+"'>"+F(Ya(a,La))+"</th>";return e+="<th class='fc-agenda-gutter "+d+"'>&nbsp;</th></tr></thead>"}function l(){var a,b,c,e,f,g=Ha+"-widget-header",h=Ha+"-widget-content",i=d.getNow().stripTime(),j="";for(j+="<tbody><tr><th class='fc-agenda-axis "+g+"'>&nbsp;</th>",c="",b=0;b<wa;b++)a=Va(0,b),f=["fc-col"+b,"fc-"+Ma[a.day()],h],a.isSame(i,"day")?f.push(Ha+"-state-highlight","fc-today"):a<i?f.push("fc-past"):f.push("fc-future"),e="<td class='"+f.join(" ")+"'><div><div class='fc-day-content'><div style='position:relative'>&nbsp;</div></div></div></td>",c+=e;return j+=c,j+="<td class='fc-agenda-gutter "+h+"'>&nbsp;</td></tr></tbody>"}
// TODO: data-date on the cells
/* Dimensions
	-----------------------------------------------------------------------*/
function m(a){void 0===a&&(a=ma),ma=a,$a={};var b=X.position().top,c=fa.position().top,d=Math.min(// total body height, including borders
a-b,// when scrollbars
ja.height()+c+1);aa.height(d-x(_)),ba.css("top",b),fa.height(d-c-1);
// the stylesheet guarantees that the first row has no border.
// this allows .height() to work well cross-browser.
var e=ja.find("tr:first").height()+1,f=ja.find("tr:eq(1)").height();
// HACK: i forget why we do this, but i think a cross-browser issue
ra=(e+f)/2,ta=qa/sa,va=ra/ta}function n(b){la=b,Fa.clear(),Ga.clear();var c=V.find("th:first");da&&(c=c.add(da.find("th:first"))),c=c.add(ja.find("th:first")),na=0,r(c.width("").each(function(b,c){na=Math.max(na,a(c).outerWidth())}),na);var d=U.find(".fc-agenda-gutter");da&&(d=d.add(da.find("th.fc-agenda-gutter")));var e=fa[0].clientWidth;// needs to be done after axisWidth (for IE7)
pa=fa.width()-e,pa?(r(d,pa),d.show().prev().removeClass("fc-last")):d.hide().prev().addClass("fc-last"),oa=Math.floor((e-na)/wa),r(W.slice(0,-1),oa)}/* Scrolling
	-----------------------------------------------------------------------*/
function o(){// +1 for the border
function a(){fa.scrollTop(c)}var c=K(b.duration(Na("scrollTime")))+1;a(),setTimeout(a,0)}function p(){// after the view has been freshly rendered and sized
o()}/* Slot/Day clicking and binding
	-----------------------------------------------------------------------*/
function q(a){a.click(u).mousedown(Ta)}function t(a){a.click(u).mousedown(P)}function u(a){if(!Na("selectable")){// if selectable, SelectionManager will worry about dayClick
var b=Math.min(wa-1,Math.floor((a.pageX-U.offset().left-na)/oa)),c=Va(0,b),e=this.parentNode.className.match(/fc-slot(\d+)/);// TODO: maybe use data
if(e){var f=parseInt(e[1],10);c.add(Ja+f*qa),c=d.rezoneDate(c),Oa("dayClick",Y[b],c,a)}else Oa("dayClick",Y[b],c,a)}}/* Semi-transparent Overlay Helpers
	-----------------------------------------------------*/
// TODO: should be consolidated with BasicView's methods
function v(a,b,c){// overlayEnd is exclusive
c&&ya.build();for(var d=Xa(a,b),e=0;e<d.length;e++){var f=d[e];q(w(f.row,f.leftCol,f.row,f.rightCol))}}function w(a,b,c,d){// only for all-day?
var e=ya.rect(a,b,c,d,ba);return Pa(e,ba)}function y(a,b){
// normalize, because dayStart/dayEnd have stripped time+zone
a=a.clone().stripZone(),b=b.clone().stripZone();for(var c=0;c<wa;c++){// loop through the day columns
var d=Va(0,c),e=d.clone().add(1,"days"),f=d<a?a:d,g=e<b?e:b;// the min of the two
if(f<g){var h=ya.rect(0,c,0,c,ha),i=J(f,d),j=J(g,d);h.top=i,h.height=j-i,t(Pa(h,ha))}}}function z(a){return Fa.left(a)}function A(a){return Ga.left(a)}function B(a){return Fa.right(a)}function D(a){return Ga.right(a)}
// NOTE: the row index of these "cells" doesn't correspond to the slot index, but rather the "snap" index
function E(a){// TODO: remove because mom.hasTime() from realCellToDate() is better
return Na("allDaySlot")&&!a.row}function G(a){// ugh "real" ... but blame it on our abuse of the "cell" system
var c=Va(0,a.col),e=a.row;return Na("allDaySlot")&&e--,e>=0&&(c.time(b.duration(Ja+e*sa)),c=d.rezoneDate(c)),c}function J(a,c){return K(b.duration(a.clone().stripZone()-c.clone().stripTime()))}function K(a){// time is a duration
if(a<Ja)return 0;if(a>=Ka)return ja.height();var b=(a-Ja)/qa,c=Math.floor(b),d=b-c,e=$a[c];
// find the position of the corresponding <tr>
// need to use this tecnhique because not all rows are rendered at same height sometimes.
void 0===e&&(e=$a[c]=ja.find("tr").eq(c).find("td div")[0].offsetTop);var f=e-1+// because first row doesn't have a top border
d*ra;// part-way through the row
return f=Math.max(f,0)}/* Selection
	---------------------------------------------------------------------------------*/
function L(a){return a.hasTime()?a.clone().add(qa):a.clone().add(1,"days")}function M(a,b){a.hasTime()||b.hasTime()?N(a,b):Na("allDaySlot")&&v(a,b,!0)}function N(b,c){var d=Na("selectHelper");if(ya.build(),d){var e=Wa(b).col;if(e>=0&&e<wa){// only works when times are on same day
var f=ya.rect(0,e,0,e,ha),g=J(b,b),h=J(c,b);if(h>g){if(// protect against selections that are entirely before or after visible range
f.top=g,f.height=h-g,f.left+=2,f.width-=5,a.isFunction(d)){var i=d(b,c);i&&(f.position="absolute",ka=a(i).css(f).appendTo(ha))}else f.isStart=!0,// conside rect a "seg" now
f.isEnd=!0,//
ka=a(Ua({title:"",start:b,end:c,className:["fc-select-helper"],editable:!1},f)),ka.css("opacity",Na("dragOpacity"));ka&&(t(ka),ha.append(ka),r(ka,f.width,!0),// needs to be after appended
s(ka,f.height,!0))}}}else y(b,c)}function O(){Qa(),ka&&(ka.remove(),ka=null)}function P(b){if(1==b.which&&Na("selectable")){// ev.which==1 means left mouse button
Sa(b);var c;Da.start(function(a,b){if(O(),a&&a.col==b.col&&!E(a)){var d=G(b),e=G(a);c=[d,d.clone().add(sa),// calculate minutes depending on selection slot minutes
e,e.clone().add(sa)].sort(C),N(c[0],c[3])}else c=null},b),a(document).one("mouseup",function(a){Da.stop(),c&&(+c[0]==+c[1]&&Q(c[0],a),Ra(c[0],c[3],a))})}}function Q(a,b){Oa("dayClick",Y[Wa(a).col],a,b)}/* External Dragging
	--------------------------------------------------------------------------------*/
function R(a,b,c){Da.start(function(a){if(Qa(),a){var b=G(a),c=b.clone();b.hasTime()?(c.add(d.defaultTimedEventDuration),y(b,c)):(c.add(d.defaultAllDayEventDuration),v(b,c))}},b)}function S(a,b,c){var d=Da.stop();Qa(),d&&Oa("drop",a,G(d),b,c)}var T=this;
// exports
T.renderAgenda=f,T.setWidth=n,T.setHeight=m,T.afterRender=p,T.computeDateTop=J,T.getIsCellAllDay=E,T.allDayRow=function(){return ea},// badly named
T.getCoordinateGrid=function(){return ya},// specifically for AgendaEventRenderer
T.getHoverListener=function(){return Da},T.colLeft=z,T.colRight=B,T.colContentLeft=A,T.colContentRight=D,T.getDaySegmentContainer=function(){return ca},T.getSlotSegmentContainer=function(){return ia},T.getSlotContainer=function(){return ha},T.getRowCnt=function(){return 1},T.getColCnt=function(){return wa},T.getColWidth=function(){return oa},T.getSnapHeight=function(){return va},T.getSnapDuration=function(){return sa},T.getSlotHeight=function(){return ra},T.getSlotDuration=function(){return qa},T.getMinTime=function(){return Ja},T.getMaxTime=function(){return Ka},T.defaultSelectionEnd=L,T.renderDayOverlay=v,T.renderSelection=M,T.clearSelection=O,T.reportDayClick=Q,// selection mousedown hack
T.dragStart=R,T.dragStop=S,
// imports
ua.call(T,c,d,e),Aa.call(T),za.call(T),ga.call(T);var U,V,W,X,Y,Z,$,_,aa,ba,ca,da,ea,fa,ha,ia,ja,ka,la,ma,na,oa,pa,qa,ra,sa,ta,va,wa,xa,ya,Da,Fa,Ga,Ha,Ia,Ja,Ka,La,Na=T.opt,Oa=T.trigger,Pa=T.renderOverlay,Qa=T.clearOverlays,Ra=T.reportSelection,Sa=T.unselect,Ta=T.daySelectionMousedown,Ua=T.slotSegHtml,Va=T.cellToDate,Wa=T.dateToCell,Xa=T.rangeToSegments,Ya=d.formatDate,Za=d.calculateWeekNumber,$a={};/* Rendering
	-----------------------------------------------------------------------------*/
H(c.addClass("fc-agenda")),/* Coordinate Utilities
	-----------------------------------------------------------------------------*/
ya=new Ba(function(b,c){function d(a){return Math.max(i,Math.min(j,a))}var e,f,g;W.each(function(b,d){e=a(d),f=e.offset().left,b&&(g[1]=f),g=[f],c[b]=g}),g[1]=f+e.outerWidth(),Na("allDaySlot")&&(e=ea,f=e.offset().top,b[0]=[f,f+e.outerHeight()]);for(var h=ha.offset().top,i=fa.offset().top,j=i+fa.outerHeight(),k=0;k<xa*ta;k++)// adapt slot count to increased/decreased selection slot count
b.push([d(h+va*k),d(h+va*(k+1))])}),Da=new Ca(ya),Fa=new Ea(function(a){return Z.eq(a)}),Ga=new Ea(function(a){return $.eq(a)})}function ga(){/* Rendering
	----------------------------------------------------------------------------*/
function c(a,b){var c,d=a.length,f=[],h=[];for(c=0;c<d;c++)a[c].allDay?f.push(a[c]):h.push(a[c]);n("allDaySlot")&&(V(f,b),v()),g(e(h),b)}function d(){w().empty(),y().empty()}function e(a){var b,c,d,e,g,h=G(),i=W(),j=X(),k=[];for(c=0;c<h;c++)// returns a new order
for(b=E(0,c),g=f(a,b.clone().time(i),b.clone().time(j)),g=ha(g),d=0;d<g.length;d++)e=g[d],e.col=c,k.push(e);return k}function f(a,b,c){
// normalize, because all dates will be compared w/o zones
b=b.clone().stripZone(),c=c.clone().stripZone();var d,e,f,g,h,i,j,k,l=[],m=a.length;for(d=0;d<m;d++)e=a[d],
// get dates, make copies, then strip zone to normalize
f=e.start.clone().stripZone(),g=$(e).stripZone(),g>b&&f<c&&(f<b?(h=b.clone(),j=!1):(h=f,j=!0),g>c?(i=c.clone(),k=!1):(i=g,k=!0),l.push({event:e,start:h,end:i,isStart:j,isEnd:k}));return l.sort(qa)}
// renders events in the 'time slots' at the bottom
// TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
// TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)
function g(b,c){var d,e,f,g,j,k,l,m,p,r,s,u,v,w,z,B,E=b.length,F="",G=y(),H=n("isRTL");
// calculate position/dimensions, create html
for(d=0;d<E;d++)e=b[d],f=e.event,g=A(e.start,e.start),j=A(e.end,e.start),k=C(e.col),l=D(e.col),m=l-k,
// shave off space on right near scrollbars (2.5%)
// TODO: move this to CSS somehow
l-=.025*m,m=l-k,p=m*(e.forwardCoord-e.backwardCoord),n("slotEventOverlap")&&(
// double the width while making sure resize handle is visible
// (assumed to be 20px wide)
p=Math.max(2*(p-10),p)),H?(s=l-e.backwardCoord*m,r=s-p):(r=k+e.backwardCoord*m,s=r+p),
// make sure horizontal coordinates are in bounds
r=Math.max(r,k),s=Math.min(s,l),p=s-r,e.top=g,e.left=r,e.outerWidth=p,e.outerHeight=j-g,F+=h(f,e);
// retrieve elements, run through eventRender callback, bind event handlers
for(G[0].innerHTML=F,// faster than html()
u=G.children(),d=0;d<E;d++)e=b[d],f=e.event,v=a(u[d]),// faster than eq()
w=o("eventRender",f,f,v),w===!1?v.remove():(w&&w!==!0&&(v.remove(),v=a(w).css({position:"absolute",top:e.top,left:e.left}).appendTo(G)),e.element=v,f._id===c?i(f,v,e):v[0]._fci=d,O(f,v));
// record event sides and title positions
for(q(G,b,i),d=0;d<E;d++)e=b[d],(v=e.element)&&(e.vsides=x(v,!0),e.hsides=t(v,!0),z=v.find(".fc-event-title"),z.length&&(e.contentTop=z[0].offsetTop));
// set all positions/dimensions at once
for(d=0;d<E;d++)e=b[d],(v=e.element)&&(v[0].style.width=Math.max(0,e.outerWidth-e.hsides)+"px",B=Math.max(0,e.outerHeight-e.vsides),v[0].style.height=B+"px",f=e.event,void 0!==e.contentTop&&B-e.contentTop<10&&(
// not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
v.find("div.fc-event-time").text(Z(f.start,n("timeFormat"))+" - "+f.title),v.find("div.fc-event-title").remove()),o("eventAfterRender",f,f,v))}function h(a,b){var c="<",d=a.url,e=J(a,n),f=["fc-event","fc-event-vert"];return p(a)&&f.push("fc-event-draggable"),b.isStart&&f.push("fc-event-start"),b.isEnd&&f.push("fc-event-end"),f=f.concat(a.className),a.source&&(f=f.concat(a.source.className||[])),c+=d?"a href='"+F(a.url)+"'":"div",c+=" class='"+f.join(" ")+"' style='position:absolute;top:"+b.top+"px;left:"+b.left+"px;"+e+"'><div class='fc-event-inner'><div class='fc-event-time'>"+F(m.getEventTimeText(a))+"</div><div class='fc-event-title'>"+F(a.title||"")+"</div></div><div class='fc-event-bg'></div>",b.isEnd&&r(a)&&(c+="<div class='ui-resizable-handle ui-resizable-s'>=</div>"),c+="</"+(d?"a":"div")+">"}function i(a,b,c){var d=b.find("div.fc-event-time");p(a)&&k(a,b,d),c.isEnd&&r(a)&&l(a,b,d),u(a,b)}/* Dragging
	-----------------------------------------------------------------------------------*/
// when event starts out FULL-DAY
// overrides DayEventRenderer's version because it needs to account for dragging elements
// to and from the slot area.
function j(a,c,d){function e(){j||(c.width(f).height("").draggable("option","grid",null),j=!0)}var f,g,h,i=d.isStart,j=!0,k=z(),l=H(),m=W(),p=M(),q=L(),r=K(),t=I();c.draggable({opacity:n("dragOpacity","month"),// use whatever the month view was using
revertDuration:n("dragRevertDuration"),start:function(b,d){o("eventDragStart",c[0],a,b,d),Q(a,c),f=c.width(),k.start(function(b,d){if(U(),b){g=!1;var f=E(0,d.col),k=E(0,b.col);h=k.diff(f,"days"),b.row?// mouse is over bottom slots
i?j&&(
// convert event to temporary slot-event
c.width(l-10),// don't use entire width
s(c,Y.defaultTimedEventDuration/p*q),// the default height
c.draggable("option","grid",[l,1]),j=!1):g=!0:(// on full-days
T(a.start.clone().add(h,"days"),$(a).add(h,"days")),e()),g=g||j&&!h}else e(),g=!0;c.draggable("option","revert",g)},b,"drag")},stop:function(d,f){if(k.stop(),U(),o("eventDragStop",c[0],a,d,f),g)// hasn't moved or is out of bounds (draggable has already reverted)
e(),c.css("filter",""),// clear IE opacity side-effects
P(a,c);else{// changed!
var i,l,n=a.start.clone().add(h,"days");j||(l=Math.round((c.offset().top-N().offset().top)/t),// why not use ui.offset.top?
i=b.duration(m+l*r),n=Y.rezoneDate(n.clone().time(i))),R(c[0],a,n,d,f)}}})}
// when event starts out IN TIMESLOTS
function k(a,b,c){function d(){U(),h&&(j?(c.hide(),b.draggable("option","grid",null),// disable grid snapping
T(t,u)):(e(),c.css("display",""),// show() was causing display=inline
b.draggable("option","grid",[x,y])))}function e(){t&&// must of had a state change
c.text(m.getEventTimeText(t,a.end?u:null))}var f,g,h,i,j,k,l,p,q,r,s,t,u,v=m.getCoordinateGrid(),w=G(),x=H(),y=I(),z=K();b.draggable({scroll:!1,grid:[x,y],axis:1==w&&"y",opacity:n("dragOpacity"),revertDuration:n("dragRevertDuration"),start:function(c,d){o("eventDragStart",b[0],a,c,d),Q(a,b),v.build(),
// initialize states
f=b.position(),g=v.cell(c.pageX,c.pageY),h=i=!0,j=k=B(g),l=p=0,q=0,r=s=0,t=null,u=null},drag:function(c,e){
// NOTE: this `cell` value is only useful for determining in-bounds and all-day.
// Bad for anything else due to the discrepancy between the mouse position and the
// element position while snapping. (problem revealed in PR #55)
//
// PS- the problem exists for draggableDayEvent() when dragging an all-day event to a slot event.
// We should overhaul the dragging system and stop relying on jQuery UI.
var m=v.cell(c.pageX,c.pageY);if(
// update states
h=!!m){if(j=B(m),
// calculate column delta
l=Math.round((e.position.left-f.left)/x),l!=p){
// calculate the day delta based off of the original clicked column and the column delta
var n=E(0,g.col),o=g.col+l;o=Math.max(0,o),o=Math.min(w-1,o);var A=E(0,o);q=A.diff(n,"days")}
// calculate minute delta (only if over slots)
j||(r=Math.round((e.position.top-f.top)/y))}
// any state changes?
h==i&&j==k&&l==p&&r==s||(
// compute new dates
j?(t=a.start.clone().stripTime().add(q,"days"),u=t.clone().add(Y.defaultAllDayEventDuration)):(t=a.start.clone().add(r*z).add(q,"days"),u=$(a).add(r*z).add(q,"days")),d(),
// update previous states for next time
i=h,k=j,p=l,s=r),
// if out-of-bounds, revert when done, and vice versa.
b.draggable("option","revert",!h)},stop:function(c,e){U(),o("eventDragStop",b[0],a,c,e),h&&(j||q||r)?// changed!
R(b[0],a,t,c,e):(// either no change or out-of-bounds (draggable has already reverted)
// reset states for next time, and for updateUI()
h=!0,j=!1,l=0,q=0,r=0,d(),b.css("filter",""),// clear IE opacity side-effects
// sometimes fast drags make event revert to wrong position, so reset.
// also, if we dragged the element out of the area because of snapping,
// but the *mouse* is still in bounds, we need to reset the position.
b.css(f),P(a,b))}})}/* Resizing
	--------------------------------------------------------------------------------------*/
function l(a,b,c){var d,e,f,g=I(),h=K();b.resizable({handles:{s:".ui-resizable-handle"},grid:g,start:function(c,f){d=e=0,Q(a,b),o("eventResizeStart",b[0],a,c,f)},resize:function(i,j){if(
// don't rely on ui.size.height, doesn't take grid into account
d=Math.round((Math.max(g,b.height())-j.originalSize.height)/g),d!=e){f=$(a).add(h*d);var k;// has there been a change?
k=d?m.getEventTimeText(a.start,f):m.getEventTimeText(a),c.text(k),e=d}},stop:function(c,e){o("eventResizeStop",b[0],a,c,e),d?S(b[0],a,f,c,e):P(a,b)}})}var m=this;
// exports
m.renderEvents=c,m.clearEvents=d,m.slotSegHtml=h,
// imports
va.call(m);var n=m.opt,o=m.trigger,p=m.isEventDraggable,r=m.isEventResizable,u=m.eventElementHandlers,v=m.setHeight,w=m.getDaySegmentContainer,y=m.getSlotSegmentContainer,z=m.getHoverListener,A=m.computeDateTop,B=m.getIsCellAllDay,C=m.colContentLeft,D=m.colContentRight,E=m.cellToDate,G=m.getColCnt,H=m.getColWidth,I=m.getSnapHeight,K=m.getSnapDuration,L=m.getSlotHeight,M=m.getSlotDuration,N=m.getSlotContainer,O=m.reportEventElement,P=m.showEvents,Q=m.hideEvents,R=m.eventDrop,S=m.eventResize,T=m.renderDayOverlay,U=m.clearOverlays,V=m.renderDayEvents,W=m.getMinTime,X=m.getMaxTime,Y=m.calendar,Z=Y.formatDate,$=Y.getEventEnd;
// overrides
m.draggableDayEvent=j}/* Agenda Event Segment Utilities
-----------------------------------------------------------------------------*/
// Sets the seg.backwardCoord and seg.forwardCoord on each segment and returns a new
// list in the order they should be placed into the DOM (an implicit z-index).
function ha(a){var b,c=ia(a),d=c[0];if(ja(c),d){for(b=0;b<d.length;b++)ka(d[b]);for(b=0;b<d.length;b++)la(d[b],0,0)}return ma(c)}
// Builds an array of segments "levels". The first level will be the leftmost tier of segments
// if the calendar is left-to-right, or the rightmost if the calendar is right-to-left.
function ia(a){var b,c,d,e=[];for(b=0;b<a.length;b++){
// go through all the levels and stop on the first level where there are no collisions
for(c=a[b],d=0;d<e.length&&na(c,e[d]).length;d++);(e[d]||(e[d]=[])).push(c)}return e}
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function ja(a){var b,c,d,e,f;for(b=0;b<a.length;b++)for(c=a[b],d=0;d<c.length;d++)for(e=c[d],e.forwardSegs=[],f=b+1;f<a.length;f++)na(e,a[f],e.forwardSegs)}
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function ka(a){var b,c,d=a.forwardSegs,e=0;if(void 0===a.forwardPressure){// not already computed
for(b=0;b<d.length;b++)c=d[b],
// figure out the child's maximum forward path
ka(c),
// either use the existing maximum, or use the child's forward pressure
// plus one (for the forwardSeg itself)
e=Math.max(e,1+c.forwardPressure);a.forwardPressure=e}}
// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a "series", which means consecutive segments with the same pressure
// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
function la(a,b,c){var d,e=a.forwardSegs;if(void 0===a.forwardCoord)// # of segments in the series
// use this segment's coordinates to computed the coordinates of the less-pressurized
// forward segments
for(// not already computed
e.length?(
// sort highest pressure first
e.sort(pa),
// this segment's forwardCoord will be calculated from the backwardCoord of the
// highest-pressure forward segment.
la(e[0],b+1,c),a.forwardCoord=e[0].backwardCoord):
// if there are no forward segments, this segment should butt up against the edge
a.forwardCoord=1,
// calculate the backwardCoord from the forwardCoord. consider the series
a.backwardCoord=a.forwardCoord-(a.forwardCoord-c)/(// available width for series
b+1),d=0;d<e.length;d++)la(e[d],0,a.forwardCoord)}
// Outputs a flat array of segments, from lowest to highest level
function ma(a){var b,c,d,e=[];for(b=0;b<a.length;b++)for(c=a[b],d=0;d<c.length;d++)e.push(c[d]);return e}
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function na(a,b,c){c=c||[];for(var d=0;d<b.length;d++)oa(a,b[d])&&c.push(b[d]);return c}
// Do these segments occupy the same vertical space?
function oa(a,b){return a.end>b.start&&a.start<b.end}
// A cmp function for determining which forward segment to rely on more when computing coordinates.
function pa(a,b){
// put higher-pressure first
// put segments that are closer to initial edge first (and favor ones with no coords yet)
// do normal sorting...
return b.forwardPressure-a.forwardPressure||(a.backwardCoord||0)-(b.backwardCoord||0)||qa(a,b)}
// A cmp function for determining which segment should be closer to the initial edge
// (the left edge on a left-to-right calendar).
function qa(a,b){// earlier start time goes first
// tie? longer-duration goes first
return a.start-b.start||b.end-b.start-(a.end-a.start)||(a.event.title||"").localeCompare(b.event.title)}function ra(a,b){function c(a,b){var c=a.clone().stripTime().add(b,"days");return c=e.skipHiddenDays(c,b<0?-1:1)}function d(a){e.start=e.intervalStart=a.clone().stripTime(),e.end=e.intervalEnd=e.start.clone().add(1,"days"),e.title=b.formatDate(e.start,e.opt("titleFormat")),e.renderResource(f().length)}// TODO: make a DayView mixin
var e=this;
// exports
e.incrementDate=c,e.render=d,
// imports
sa.call(e,a,b,"resourceDay");var f=e.getResources}
// TODO: make it work in quirks mode (event corners, all-day height)
// TODO: test liquid width, especially in IE6
function sa(c,d,e){function f(a){Da=a,g(),X?i():// first time rendering?
h()}function g(){Ka=Qa("theme")?"ui":"fc",La=Qa("isRTL"),Pa=Qa("columnFormat"),Na=b.duration(Qa("minTime")),Oa=b.duration(Qa("maxTime")),sa=b.duration(Qa("slotDuration")),wa=Qa("snapDuration"),wa=wa?b.duration(wa):sa}/* Build DOM
	-----------------------------------------------------------------------*/
function h(){var d,e,f,g,h=Ka+"-widget-header",j=Ka+"-widget-content",k=sa.asMinutes()%15===0;for(i(),ea=a("<div style='position:absolute;z-index:2;left:0;width:100%'/>").appendTo(c),Qa("allDaySlot")?(fa=a("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(ea),d="<table style='width:100%' class='fc-agenda-allday' cellspacing='0'><tr><th class='"+h+" fc-agenda-axis'>"+(Qa("allDayHTML")||F(Qa("allDayText")))+"</th><td><div class='fc-day-content'><div style='position:relative'/></div></td><th class='"+h+" fc-agenda-gutter'>&nbsp;</th></tr></table>",ga=a(d).appendTo(ea),ha=ga.find("tr"),q(ha.find("td")),ea.append("<div class='fc-agenda-divider "+h+"'><div class='fc-agenda-divider-inner'/></div>")):fa=a([]),ia=a("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>").appendTo(ea),ja=a("<div style='position:relative;width:100%;overflow:hidden'/>").appendTo(ia),ka=a("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(ja),d="<table class='fc-agenda-slots' style='width:100%' cellspacing='0'><tbody>",e=b.duration(+Na),// i wish there was .clone() for durations
Fa=0;e<Oa;)f=W.start.clone().time(e),// will be in UTC but that's good. to avoid DST issues
g=f.minutes(),d+="<tr class='fc-slot"+Fa+" "+(g?"fc-minor":"")+"'><th class='fc-agenda-axis "+h+"'>"+(k&&g?"&nbsp;":F($a(f,Qa("axisFormat"))))+"</th><td class='"+j+"'><div style='position:relative'>&nbsp;</div></td></tr>",e.add(sa),Fa++;d+="</tbody></table>",la=a(d).appendTo(ja),t(la.find("td"))}/* Build Day Table
	-----------------------------------------------------------------------*/
function i(){var b=j();X&&X.remove(),X=a(b).appendTo(c),Y=X.find("thead"),Z=Y.find("th").slice(1,-1),// exclude gutter
$=X.find("tbody"),_=$.find("td").slice(0,-1),// exclude gutter
aa=_.find("> div"),ba=_.find(".fc-day-content > div"),ca=_.eq(0),da=aa.eq(0),I(Y.add(Y.find("tr"))),I($.add($.find("tr")))}function j(){var a="<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'>"+k()+l()+"</table>";return a}function k(){var a,b,c,d=Ka+"-widget-header",e="";for(e+="<thead><tr>",Qa("weekNumbers")?(a=Xa(0,0),b=_a(a),La?b+=Qa("weekNumberTitle"):b=Qa("weekNumberTitle")+b,e+="<th class='fc-agenda-axis fc-week-number "+d+"'>"+F(b)+"</th>"):e+="<th class='fc-agenda-axis "+d+"'>&nbsp;</th>",c=0;c<Da;c++){var f=cb()[c],g=[// added
"fc-col"+c,f.className,d];e+="<th class='"+g.join(" ")+"'>"+F(f.name)+"</th>"}return e+="<th class='fc-agenda-gutter "+d+"'>&nbsp;</th></tr></thead>"}function l(){var a,b,c,e,f,g=Ka+"-widget-header",h=Ka+"-widget-content",i=d.getNow().stripTime(),j="";for(j+="<tbody><tr><th class='fc-agenda-axis "+g+"'>&nbsp;</th>",c="",b=0;b<(Da||1);b++){var k=cb()[b];a=W.intervalStart.clone(),f=["fc-col"+b,"fc-"+Ma[a.day()],h],k&&k.className&&f.push(k.className),a.isSame(i,"day")?f.push(Ka+"-state-highlight","fc-today"):a<i?f.push("fc-past"):f.push("fc-future"),e="<td class='"+f.join(" ")+"'><div><div class='fc-day-content'><div style='position:relative'>&nbsp;</div></div></div></td>",c+=e}return j+=c,j+="<td class='fc-agenda-gutter "+h+"'>&nbsp;</td></tr></tbody>"}
// TODO: data-date on the cells
/* Dimensions
	-----------------------------------------------------------------------*/
function m(a){void 0===a&&(a=oa),oa=a,bb={};var b=$.position().top,c=ia.position().top,d=Math.min(// total body height, including borders
a-b,// when scrollbars
la.height()+c+1);da.height(d-x(ca)),ea.css("top",b),ia.height(d-c-1);
// the stylesheet guarantees that the first row has no border.
// this allows .height() to work well cross-browser.
var e=la.find("tr:first").height()+1,f=la.find("tr:eq(1)").height();
// HACK: i forget why we do this, but i think a cross-browser issue
va=(e+f)/2,xa=sa/wa,ya=va/xa}function n(b){na=b,Ia.clear(),Ja.clear();var c=Y.find("th:first");ga&&(c=c.add(ga.find("th:first"))),c=c.add(la.find("th:first")),pa=0,r(c.width("").each(function(b,c){pa=Math.max(pa,a(c).outerWidth())}),pa);var d=X.find(".fc-agenda-gutter");ga&&(d=d.add(ga.find("th.fc-agenda-gutter")));var e=ia[0].clientWidth;// needs to be done after axisWidth (for IE7)
ra=ia.width()-e,ra?(r(d,ra),d.show().prev().removeClass("fc-last")):d.hide().prev().addClass("fc-last"),qa=Math.floor((e-pa)/Da),r(Z.slice(0,-1),qa)}/* Scrolling
	-----------------------------------------------------------------------*/
function o(){// +1 for the border
function a(){ia.scrollTop(c)}var c=K(b.duration(Qa("scrollTime")))+1;a(),setTimeout(a,0)}function p(){// after the view has been freshly rendered and sized
o()}/* Slot/Day clicking and binding
	-----------------------------------------------------------------------*/
function q(a){a.click(u).mousedown(V)}function t(a){a.click(u).mousedown(P)}function u(a){if(!Qa("selectable")){// if selectable, SelectionManager will worry about dayClick
var b=Math.min(Da-1,Math.floor((a.pageX-X.offset().left-pa)/qa)),c=Xa(0,0),e=this.parentNode.className.match(/fc-slot(\d+)/);// added
if(// TODO: maybe use data
a.data=cb()[b],e){var f=parseInt(e[1],10);c.add(Na+f*sa),c=d.rezoneDate(c),Ra("dayClick",_[b],c,a)}else Ra("dayClick",_[b],c,a)}}/* Semi-transparent Overlay Helpers
	-----------------------------------------------------*/
// TODO: should be consolidated with BasicView's methods
function v(a,b,c,d){// overlayEnd is exclusive
c&&Ga.build();for(var e=Za(a,b),f=0;f<e.length;f++){var g=e[f];q(w(g.row,d,g.row,d))}}function w(a,b,c,d){// only for all-day?
var e=Ga.rect(a,b,c,d,ea);return Sa(e,ea)}function y(a,b,c){
// normalize, because dayStart/dayEnd have stripped time+zone
a=a.clone().stripZone(),b=b.clone().stripZone();var d=Xa(0,0),e=d.clone().add(1,"days"),f=d<a?a:d,g=e<b?e:b;// the min of the two
if(f<g){var h=Ga.rect(0,c,0,c,ja),i=J(f,d),j=J(g,d);h.top=i,h.height=j-i,t(Sa(h,ja))}}function z(a){return Ia.left(a)}function A(a){return Ja.left(a)}function B(a){return Ia.right(a)}function D(a){return Ja.right(a)}
// NOTE: the row index of these "cells" doesn't correspond to the slot index, but rather the "snap" index
function E(a){// TODO: remove because mom.hasTime() from realCellToDate() is better
return Qa("allDaySlot")&&!a.row}function G(a){// ugh "real" ... but blame it on our abuse of the "cell" system
var c=Xa(0,0),e=a.row;return Qa("allDaySlot")&&e--,e>=0&&(c.time(b.duration(Na+e*wa)),c=d.rezoneDate(c)),c}function J(a,c){return K(b.duration(a.clone().stripZone()-c.clone().stripTime()))}function K(a){// time is a duration
if(a<Na)return 0;if(a>=Oa)return la.height();var b=(a-Na)/sa,c=Math.floor(b),d=b-c,e=bb[c];
// find the position of the corresponding <tr>
// need to use this tecnhique because not all rows are rendered at same height sometimes.
void 0===e&&(e=bb[c]=la.find("tr").eq(c).find("td div")[0].offsetTop);var f=e-1+// because first row doesn't have a top border
d*va;// part-way through the row
return f=Math.max(f,0)}/* Selection
	---------------------------------------------------------------------------------*/
function L(a){return a.hasTime()?a.clone().add(sa):a.clone().add(1,"days")}function M(a,b,c){a.hasTime()||b.hasTime()?N(a,b):Qa("allDaySlot")&&v(a,b,!0,c)}function N(b,c,d){var e=Qa("selectHelper");if(Ga.build(),e){if(d=d||Ya(b).col,d>=0&&d<Da){// only works when times are on same day
var f=Ga.rect(0,d,0,d,ja),g=J(b,b),h=J(c,b);if(h>g){if(// protect against selections that are entirely before or after visible range
f.top=g,f.height=h-g,f.left+=2,f.width-=5,a.isFunction(e)){var i=e(b,c);i&&(f.position="absolute",ma=a(i).css(f).appendTo(ja))}else f.isStart=!0,// conside rect a "seg" now
f.isEnd=!0,//
ma=a(Wa({title:"",start:b,end:c,className:["fc-select-helper"],editable:!1},f)),ma.css("opacity",Qa("dragOpacity"));ma&&(t(ma),ja.append(ma),r(ma,f.width,!0),// needs to be after appended
s(ma,f.height,!0))}}}else y(b,c,d)}function O(){Ta(),ma&&(ma.remove(),ma=null)}function P(b){if(1==b.which&&Qa("selectable")){// ev.which==1 means left mouse button
Va(b);var c,d;Ha.start(function(a,b){if(O(),a&&a.col==b.col&&!E(a)){d=a.col;var e=G(b),f=G(a);c=[e,e.clone().add(wa),// calculate minutes depending on selection slot minutes
f,f.clone().add(wa)].sort(C),N(c[0],c[3],a.col)}else c=null},b),a(document).one("mouseup",function(a){Ha.stop(),c&&(+c[0]==+c[1]&&Q(c[0],a),a.data=cb()[d],// added
Ua(c[0],c[3],a))})}}function Q(a,b){Ra("dayClick",_[Ya(a).col],a,b)}/* Event Modification Reporting
	---------------------------------------------------------------------------------*/
function R(a,b,c,e,f,g){var h=d.mutateResourceEvent(b,c,e,null);Ra("eventDrop",a,b,h.dateDelta,function(){h.undo(),ab(b._id)},f,g),ab(b._id)}function S(a,b,c,e,f){var g=d.mutateResourceEvent(b,b.resources,null,c);Ra("eventResize",a,b,g.durationDelta,function(){g.undo(),ab(b._id)},e,f),ab(b._id)}/* External Dragging
	--------------------------------------------------------------------------------*/
function T(a,b,c){Ha.start(function(a){if(Ta(),a){var b=G(a),c=b.clone();b.hasTime()?(c.add(d.defaultTimedEventDuration),y(b,c,a.col)):(c.add(d.defaultAllDayEventDuration),v(b,c,!0,a.col))}},b)}function U(a,b,c){var d=Ha.stop();Ta(),d&&(b.data=cb()[d.col],Ra("drop",a,G(d),b,c))}/* OVERRIDES */
function V(b){var c,d=W.getIsCellAllDay,e=W.getHoverListener(),f=W.reportDayClick;if(1==b.which&&Qa("selectable")){// which==1 means left mouse button
Va(b);var g;e.start(function(a,b){// TODO: maybe put cellToDate/getIsCellAllDay info in cell
O(),a&&d(a)?(c=a.col,g=[G(b),G(a)].sort(C),M(g[0],g[1],c)):g=null},b),a(document).one("mouseup",function(a){e.stop(),g&&(+g[0]==+g[1]&&f(g[0],!0,a),a.data=cb()[c],Ua(g[0],g[1],a))})}}var W=this;
// exports
W.renderResource=f,W.setWidth=n,W.setHeight=m,W.afterRender=p,W.computeDateTop=J,W.getIsCellAllDay=E,W.allDayRow=function(){return ha},// badly named
W.getCoordinateGrid=function(){return Ga},// specifically for AgendaEventRenderer
W.getHoverListener=function(){return Ha},W.colLeft=z,W.colRight=B,W.colContentLeft=A,W.colContentRight=D,W.getDaySegmentContainer=function(){return fa},W.getSlotSegmentContainer=function(){return ka},W.getSlotContainer=function(){return ja},W.getRowCnt=function(){return 1},W.getColCnt=function(){return 1},W.getColWidth=function(){return qa},W.getSnapHeight=function(){return ya},W.getSnapDuration=function(){return wa},W.getSlotHeight=function(){return va},W.getSlotDuration=function(){return sa},W.getMinTime=function(){return Na},W.getMaxTime=function(){return Oa},W.defaultSelectionEnd=L,W.renderDayOverlay=v,W.renderSelection=M,W.clearSelection=O,W.reportDayClick=Q,// selection mousedown hack
W.dragStart=T,W.dragStop=U,W.getResources=d.fetchResources,
// imports
ua.call(W,c,d,e),W.eventDrop=R,W.eventResize=S,Aa.call(W),za.call(W),ta.call(W);var X,Y,Z,$,_,aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la,ma,na,oa,pa,qa,ra,sa,va,wa,xa,ya,Da,Fa,Ga,Ha,Ia,Ja,Ka,La,Na,Oa,Pa,Qa=W.opt,Ra=W.trigger,Sa=W.renderOverlay,Ta=W.clearOverlays,Ua=W.reportSelection,Va=W.unselect,Wa=W.slotSegHtml,Xa=W.cellToDate,Ya=W.dateToCell,Za=W.rangeToSegments,$a=d.formatDate,_a=d.calculateWeekNumber,ab=d.reportEventChange,bb={},cb=W.getResources;/* Rendering
	-----------------------------------------------------------------------------*/
H(c.addClass("fc-agenda")),/* Coordinate Utilities
	-----------------------------------------------------------------------------*/
Ga=new Ba(function(b,c){function d(a){return Math.max(i,Math.min(j,a))}var e,f,g;Z.each(function(b,d){e=a(d),f=e.offset().left,b&&(g[1]=f),g=[f],c[b]=g}),g[1]=f+e.outerWidth(),Qa("allDaySlot")&&(e=ha,f=e.offset().top,b[0]=[f,f+e.outerHeight()]);for(var h=ja.offset().top,i=ia.offset().top,j=i+ia.outerHeight(),k=0;k<Fa*xa;k++)// adapt slot count to increased/decreased selection slot count
b.push([d(h+ya*k),d(h+ya*(k+1))])}),Ha=new Ca(Ga),Ia=new Ea(function(a){return aa.eq(a)}),Ja=new Ea(function(a){return ba.eq(a)})}function ta(){/* Rendering
	----------------------------------------------------------------------------*/
function c(a,b){var c,d=a.length,f=[],g=[];for(c=0;c<d;c++)a[c].allDay?f.push(a[c]):g.push(a[c]);o("allDaySlot")&&(W(f,b),w()),h(e(g),b)}function d(){y().empty(),z().empty()}function e(a){var b,c,d,e,h,i=H(),j=X(),k=Y(),l=[];for(c=0;c<i;c++){b=G(0,0);// updated - should show same day for all
var m=g(aa()[c],a);// returns a new order
for(h=f(m,b.clone().time(j),b.clone().time(k)),h=ha(h),d=0;d<h.length;d++)e=h[d],e.col=c,l.push(e)}return l}function f(a,b,c){
// normalize, because all dates will be compared w/o zones
b=b.clone().stripZone(),c=c.clone().stripZone();var d,e,f,g,h,i,j,k,l=[],m=a.length;for(d=0;d<m;d++)e=a[d],
// get dates, make copies, then strip zone to normalize
f=e.start.clone().stripZone(),g=_(e).stripZone(),g>b&&f<c&&(f<b?(h=b.clone(),j=!1):(h=f,j=!0),g>c?(i=c.clone(),k=!1):(i=g,k=!0),l.push({event:e,start:h,end:i,isStart:j,isEnd:k}));return l.sort(qa)}function g(b,c){for(var d=[],e=function(c){return c.resources&&a.grep(c.resources,function(a){return a==b.id}).length},f=0;f<c.length;f++)e(c[f])&&d.push(c[f]);return d}
// renders events in the 'time slots' at the bottom
// TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
// TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)
function h(b,c){var d,e,f,g,h,k,l,m,n,r,s,u,v,w,y,A,C=b.length,F="",G=z(),H=o("isRTL");
// calculate position/dimensions, create html
for(d=0;d<C;d++)e=b[d],f=e.event,g=B(e.start,e.start),h=B(e.end,e.start),k=D(e.col),l=E(e.col),m=l-k,
// shave off space on right near scrollbars (2.5%)
// TODO: move this to CSS somehow
l-=.025*m,m=l-k,n=m*(e.forwardCoord-e.backwardCoord),o("slotEventOverlap")&&(
// double the width while making sure resize handle is visible
// (assumed to be 20px wide)
n=Math.max(2*(n-10),n)),H?(s=l-e.backwardCoord*m,r=s-n):(r=k+e.backwardCoord*m,s=r+n),
// make sure horizontal coordinates are in bounds
r=Math.max(r,k),s=Math.min(s,l),n=s-r,e.top=g,e.left=r,e.outerWidth=n,e.outerHeight=h-g,F+=i(f,e);
// retrieve elements, run through eventRender callback, bind event handlers
for(G[0].innerHTML=F,// faster than html()
u=G.children(),d=0;d<C;d++)e=b[d],f=e.event,v=a(u[d]),// faster than eq()
w=p("eventRender",f,f,v),w===!1?v.remove():(w&&w!==!0&&(v.remove(),v=a(w).css({position:"absolute",top:e.top,left:e.left}).appendTo(G)),e.element=v,f._id===c?j(f,v,e):v[0]._fci=d,P(f,v));
// record event sides and title positions
for(q(G,b,j),d=0;d<C;d++)e=b[d],(v=e.element)&&(e.vsides=x(v,!0),e.hsides=t(v,!0),y=v.find(".fc-event-title"),y.length&&(e.contentTop=y[0].offsetTop));
// set all positions/dimensions at once
for(d=0;d<C;d++)e=b[d],(v=e.element)&&(v[0].style.width=Math.max(0,e.outerWidth-e.hsides)+"px",A=Math.max(0,e.outerHeight-e.vsides),v[0].style.height=A+"px",f=e.event,void 0!==e.contentTop&&A-e.contentTop<10&&(
// not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
v.find("div.fc-event-time").text($(f.start,o("timeFormat"))+" - "+f.title),v.find("div.fc-event-title").remove()),p("eventAfterRender",f,f,v))}function i(a,b){var c="<",d=a.url,e=J(a,o),f=["fc-event","fc-event-vert"];return r(a)&&f.push("fc-event-draggable"),b.isStart&&f.push("fc-event-start"),b.isEnd&&f.push("fc-event-end"),f=f.concat(a.className),a.source&&(f=f.concat(a.source.className||[])),c+=d?"a href='"+F(a.url)+"'":"div",c+=" class='"+f.join(" ")+"' style='position:absolute;top:"+b.top+"px;left:"+b.left+"px;"+e+"'><div class='fc-event-inner'><div class='fc-event-time'>"+F(n.getEventTimeText(a))+"</div><div class='fc-event-title'>"+F(a.title||"")+"</div></div><div class='fc-event-bg'></div>",b.isEnd&&u(a)&&(c+="<div class='ui-resizable-handle ui-resizable-s'>=</div>"),c+="</"+(d?"a":"div")+">"}function j(a,b,c){var d=b.find("div.fc-event-time");r(a)&&l(a,b,d),c.isEnd&&u(a)&&m(a,b,d),v(a,b)}/* Dragging
	-----------------------------------------------------------------------------------*/
// when event starts out FULL-DAY
// overrides DayEventRenderer's version because it needs to account for dragging elements
// to and from the slot area.
function k(a,c,d){function e(){k||(c.width(f).height("").draggable("option","grid",null),k=!0)}var f,g,h,i,j=d.isStart,k=!0,l=A(),m=I(),n=X(),q=N(),r=M(),t=L(),u=K();c.draggable({opacity:o("dragOpacity","month"),// use whatever the month view was using
revertDuration:o("dragRevertDuration"),start:function(b,d){p("eventDragStart",c[0],a,b,d),R(a,c),f=c.width(),l.start(function(b,d){if(V(),b){g=!1,i=d.col;var f=G(0,d.col),l=G(0,b.col);h=l.diff(f,"days"),b.row?// mouse is over bottom slots
j?k&&(
// convert event to temporary slot-event
c.width(m-10),// don't use entire width
s(c,Z.defaultTimedEventDuration/q*r),// the default height
c.draggable("option","grid",[m,1]),k=!1):g=!0:(// on full-days
U(a.start.clone().add(h,"days"),_(a).add(h,"days"),!0,1),e()),g=g||k&&!h}else e(),g=!0;c.draggable("option","revert",g)},b,"drag")},stop:function(d,f){if(l.stop(),V(),p("eventDragStop",c[0],a,d,f),g)// hasn't moved or is out of bounds (draggable has already reverted)
e(),c.css("filter",""),// clear IE opacity side-effects
Q(a,c);else{// changed!
// calculate column delta
var h=Math.round((c.offset().left-O().offset().left)/m),j=a.resources;h!==i&&(j=[aa()[h].id]);var o,q,r=a.start.clone();k||(q=Math.round((c.offset().top-O().offset().top)/u),// why not use ui.offset.top?
o=b.duration(n+q*t),r=Z.rezoneDate(r.clone().time(o))),S(c[0],a,j,r,d,f)}}})}
// when event starts out IN TIMESLOTS
function l(a,b,c){function d(){V(),h&&(j?(c.hide(),b.draggable("option","grid",null),// disable grid snapping
U(u,v,!1,g.col+l)):(e(),c.css("display",""),// show() was causing display=inline
b.draggable("option","grid",[y,z])))}function e(){u&&// must of had a state change
c.text(n.getEventTimeText(u,a.end?v:null))}var f,g,h,i,j,k,l,m,q,r,s,t,u,v,w=n.getCoordinateGrid(),x=H(),y=I(),z=K(),A=L();b.draggable({scroll:!1,grid:[y,z],axis:1==x&&"y",opacity:o("dragOpacity"),revertDuration:o("dragRevertDuration"),start:function(c,d){p("eventDragStart",b[0],a,c,d),R(a,b),w.build(),
// initialize states
f=b.position(),g=w.cell(c.pageX,c.pageY),h=i=!0,j=k=C(g),l=m=0,q=0,r=0,s=t=0,u=null,v=null},drag:function(c,e){
// NOTE: this `cell` value is only useful for determining in-bounds and all-day.
// Bad for anything else due to the discrepancy between the mouse position and the
// element position while snapping. (problem revealed in PR #55)
//
// PS- the problem exists for draggableDayEvent() when dragging an all-day event to a slot event.
// We should overhaul the dragging system and stop relying on jQuery UI.
var g=w.cell(c.pageX,c.pageY);
// update states
h=!!g,h&&(j=C(g),
// calculate column delta
l=Math.round((e.position.left-f.left)/y),l!=m&&(
// calculate the day delta based off of the original clicked column and the column delta
r=l),
// calculate minute delta (only if over slots)
j||(s=Math.round((e.position.top-f.top)/z))),
// any state changes?
h==i&&j==k&&l==m&&s==t||(
// compute new dates
j?(u=a.start.clone().stripTime().add(q,"days"),v=u.clone().add(Z.defaultAllDayEventDuration)):(u=a.start.clone().add(s*A).add(q,"days"),v=_(a).add(s*A).add(q,"days")),d(),
// update previous states for next time
i=h,k=j,m=l,t=s),
// if out-of-bounds, revert when done, and vice versa.
b.draggable("option","revert",!h)},stop:function(c,e){if(V(),p("eventDragStop",b[0],a,c,e),h&&(j||r||s)){// changed!
var i=a.resources.slice(0),k=aa();if(r&&g.col+r<k.length){
// given we have r1/r3 
// if we move r3 to r2, then we want to maintain r1/r2.
// if we move r3 to r1, then we only want to maintain r1 - so we splice the array
var m=k[g.col+r].id,n=k[g.col].id,o=a.resources.indexOf(n),t=a.resources.indexOf(m);t>-1?i.splice(o,1):i[o]=m}S(b[0],a,i,u,c,e)}else// either no change or out-of-bounds (draggable has already reverted)
// reset states for next time, and for updateUI()
h=!0,j=!1,l=0,q=0,s=0,d(),b.css("filter",""),// clear IE opacity side-effects
// sometimes fast drags make event revert to wrong position, so reset.
// also, if we dragged the element out of the area because of snapping,
// but the *mouse* is still in bounds, we need to reset the position.
b.css(f),Q(a,b)}})}/* Resizing
	--------------------------------------------------------------------------------------*/
function m(a,b,c){var d,e,f,g=K(),h=L();b.resizable({handles:{s:".ui-resizable-handle"},grid:g,start:function(c,f){d=e=0,R(a,b),p("eventResizeStart",b[0],a,c,f)},resize:function(i,j){if(
// don't rely on ui.size.height, doesn't take grid into account
d=Math.round((Math.max(g,b.height())-j.originalSize.height)/g),d!=e){f=_(a).add(h*d);var k;// has there been a change?
k=d?n.getEventTimeText(a.start,f):n.getEventTimeText(a),c.text(k),e=d}},stop:function(c,e){p("eventResizeStop",b[0],a,c,e),d?T(b[0],a,f,c,e):Q(a,b)}})}var n=this;
// exports
n.renderEvents=c,n.clearEvents=d,n.slotSegHtml=i,
// imports
va.call(n);var o=n.opt,p=n.trigger,r=n.isEventDraggable,u=n.isEventResizable,v=n.eventElementHandlers,w=n.setHeight,y=n.getDaySegmentContainer,z=n.getSlotSegmentContainer,A=n.getHoverListener,B=n.computeDateTop,C=n.getIsCellAllDay,D=n.colContentLeft,E=n.colContentRight,G=n.cellToDate,H=function(){return aa().length},I=n.getColWidth,K=n.getSnapHeight,L=n.getSnapDuration,M=n.getSlotHeight,N=n.getSlotDuration,O=n.getSlotContainer,P=n.reportEventElement,Q=n.showEvents,R=n.hideEvents,S=n.eventDrop,T=n.eventResize,U=n.renderDayOverlay,V=n.clearOverlays,W=n.renderDayEvents,X=n.getMinTime,Y=n.getMaxTime,Z=n.calendar,$=Z.formatDate,_=Z.getEventEnd,aa=n.getResources;
// overrides
n.draggableDayEvent=k}function ua(c,d,e){function f(b,c){var d=K[b];return a.isPlainObject(d)&&!g(b)?E(d,c||e):d}function h(a,b){return d.trigger.apply(d,[a,b||G].concat(Array.prototype.slice.call(arguments,2),[G]))}/* Event Editable Boolean Calculations
	------------------------------------------------------------------------------*/
function i(a){var b=a.source||{};return L(a.startEditable,b.startEditable,f("eventStartEditable"),a.editable,b.editable,f("editable"))}function j(a){// but also need to make sure the seg.isEnd == true
var b=a.source||{};return L(a.durationEditable,b.durationEditable,f("eventDurationEditable"),a.editable,b.editable,f("editable"))}/* Event Data
	------------------------------------------------------------------------------*/
function k(){I={},J=[]}/* Event Elements
	------------------------------------------------------------------------------*/
// report when view creates an element for an event
function l(a,b){J.push({event:a,element:b}),I[a._id]?I[a._id].push(b):I[a._id]=[b]}function m(){a.each(J,function(a,b){G.trigger("eventDestroy",b.event,b.event,b.element)})}
// attaches eventClick, eventMouseover, eventMouseout
function n(a,b){b.click(function(c){if(!b.hasClass("ui-draggable-dragging")&&!b.hasClass("ui-resizable-resizing"))return h("eventClick",this,a,c)}).hover(function(b){h("eventMouseover",this,a,b)},function(b){h("eventMouseout",this,a,b)})}function o(a,b){q(a,b,"show")}function p(a,b){q(a,b,"hide")}function q(a,b,c){
// NOTE: there may be multiple events per ID (repeating events)
// and multiple segments per event
var d,e=I[a._id],f=e.length;for(d=0;d<f;d++)b&&e[d][0]==b[0]||e[d][c]()}/* Event Modification Reporting
	---------------------------------------------------------------------------------*/
function r(a,b,c,e,f){var g=d.mutateEvent(b,c,null);h("eventDrop",a,b,g.dateDelta,function(){g.undo(),H(b._id)},e,f),H(b._id)}function s(a,b,c,e,f){var g=d.mutateEvent(b,null,c);h("eventResize",a,b,g.durationDelta,function(){g.undo(),H(b._id)},e,f),H(b._id)}
// Is the current day hidden?
// `day` is a day-of-week index (0-6), or a Moment
function t(a){return b.isMoment(a)&&(a=a.day()),P[a]}function u(){return N}
// Incrementing the current day until it is no longer a hidden day, returning a copy.
// If the initial value of `date` is not a hidden day, don't do anything.
// Pass `isExclusive` as `true` if you are dealing with an end date.
// `inc` defaults to `1` (increment one day forward each time)
function v(a,b,c){var d=a.clone();for(b=b||1;P[(d.day()+(c?b:0)+7)%7];)d.add(b,"days");return d}
//
// TRANSFORMATIONS: cell -> cell offset -> day offset -> date
//
// cell -> date (combines all transformations)
// Possible arguments:
// - row, col
// - { row:#, col: # }
function w(){var a=x.apply(null,arguments),b=y(a),c=z(b);return c}
// cell -> cell offset
// Possible arguments:
// - row, col
// - { row:#, col:# }
function x(a,b){var c=G.getColCnt(),d=S?-1:1,e=S?c-1:0;"object"==typeof a&&(b=a.col,a=a.row);var f=a*c+(b*d+e);// column, adjusted for RTL (dis & dit)
return f}
// cell offset -> day offset
function y(a){var b=G.start.day();// normlize cellOffset to beginning-of-week
// first date's day of week
// # of days from full weeks
// # of days from partial last week
return a+=Q[b],7*Math.floor(a/N)+R[(a%N+N)%N]-b}
// day offset -> date
function z(a){return G.start.clone().add(a,"days")}
//
// TRANSFORMATIONS: date -> day offset -> cell offset -> cell
//
// date -> cell (combines all transformations)
function A(a){var b=B(a),c=C(b),d=D(c);return d}
// date -> day offset
function B(a){return a.clone().stripTime().diff(G.start,"days")}
// day offset -> cell offset
function C(a){var b=G.start.day();// normalize dayOffset to beginning-of-week
// first date's day of week
// # of cells from full weeks
// # of cells from partial last week
return a+=b,Math.floor(a/7)*N+Q[(a%7+7)%7]-Q[b]}
// cell offset -> cell (object with row & col keys)
function D(a){var b=G.getColCnt(),c=S?-1:1,d=S?b-1:0,e=Math.floor(a/b),f=(a%b+b)%b*c+d;// column, adjusted for RTL (dis & dit)
return{row:e,col:f}}
//
// Converts a date range into an array of segment objects.
// "Segments" are horizontal stretches of time, sliced up by row.
// A segment object has the following properties:
// - row
// - cols
// - isStart
// - isEnd
//
function F(a,b){var c=G.getRowCnt(),d=G.getColCnt(),e=[],f=B(a),g=B(b),h=+b.time();h&&h>=M&&g++,g=Math.max(g,f+1);
// loop through all the rows in the view
for(var i=C(f),j=C(g)-1,k=0;k<c;k++){
// first and last cell offset for the row
var l=k*d,m=l+d-1,n=Math.max(i,l),o=Math.min(j,m);
// make sure segment's offsets are valid and in view
if(n<=o){
// translate to cells
var p=D(n),q=D(o),r=[p.col,q.col].sort(),s=y(n)==f,t=y(o)+1==g;// +1 for comparing exclusively
e.push({row:k,leftCol:r[0],rightCol:r[1],isStart:s,isEnd:t})}}return e}var G=this;
// exports
G.element=c,G.calendar=d,G.name=e,G.opt=f,G.trigger=h,G.isEventDraggable=i,G.isEventResizable=j,G.clearEventData=k,G.reportEventElement=l,G.triggerEventDestroy=m,G.eventElementHandlers=n,G.showEvents=o,G.hideEvents=p,G.eventDrop=r,G.eventResize=s;
// t.start, t.end // moments with ambiguous-time
// t.intervalStart, t.intervalEnd // moments with ambiguous-time
// imports
var H=d.reportEventChange,I={},J=[],K=d.options,M=b.duration(K.nextDayThreshold);
// Compute the text that should be displayed on an event's element.
// Based off the settings of the view.
// Given either an event object or two arguments: a start and end date (which can be null)
G.getEventTimeText=function(a){var b,c;return 2===arguments.length?(b=arguments[0],c=arguments[1]):(b=a.start,c=a.end),c&&f("displayEventEnd")?d.formatRange(b,c,f("timeFormat")):d.formatDate(b,f("timeFormat"))},
// ====================================================================================================
// Utilities for day "cells"
// ====================================================================================================
// The "basic" views are completely made up of day cells.
// The "agenda" views have day cells at the top "all day" slot.
// This was the obvious common place to put these utilities, but they should be abstracted out into
// a more meaningful class (like DayEventRenderer).
// ====================================================================================================
// For determining how a given "cell" translates into a "date":
//
// 1. Convert the "cell" (row and column) into a "cell offset" (the # of the cell, cronologically from the first).
//    Keep in mind that column indices are inverted with isRTL. This is taken into account.
//
// 2. Convert the "cell offset" to a "day offset" (the # of days since the first visible day in the view).
//
// 3. Convert the "day offset" into a "date" (a Moment).
//
// The reverse transformation happens when transforming a date into a cell.
// exports
G.isHiddenDay=t,G.skipHiddenDays=v,G.getCellsPerWeek=u,G.dateToCell=A,G.dateToDayOffset=B,G.dayOffsetToCellOffset=C,G.cellOffsetToCell=D,G.cellToDate=w,G.cellToCellOffset=x,G.cellOffsetToDayOffset=y,G.dayOffsetToDate=z,G.rangeToSegments=F;
// internals
var N,O=f("hiddenDays")||[],P=[],Q=[],R=[],S=f("isRTL");
// initialize important internal variables
!function(){f("weekends")===!1&&O.push(0,6);
// Loop through a hypothetical week and determine which
// days-of-week are hidden. Record in both hashes (one is the reverse of the other).
for(var b=0,c=0;b<7;b++)Q[b]=c,P[b]=a.inArray(b,O)!=-1,P[b]||(R[c]=b,c++);if(N=c,!N)throw"invalid hiddenDays"}()}function va(){
// Render `events` onto the calendar, attach mouse event handlers, and call the `eventAfterRender` callback for each.
// Mouse event will be lazily applied, except if the event has an ID of `modifiedEventId`.
// Can only be called when the event container is empty (because it wipes out all innerHTML).
function b(a,b){
// do the actual rendering. Receive the intermediate "segment" data structures.
var c=d(a,!1,// don't append event elements
!0);
// report the elements to the View, for general drag/resize utilities
xa(c,function(a,b){C(a.event,b)}),
// attach mouse handlers
s(c,b),
// call `eventAfterRender` callback for each event
xa(c,function(a,b){z("eventAfterRender",a.event,a.event,b)})}
// Render an event on the calendar, but don't report them anywhere, and don't attach mouse handlers.
// Append this event element to the event container, which might already be populated with events.
// If an event's segment will have row equal to `adjustRow`, then explicitly set its top coordinate to `adjustTop`.
// This hack is used to maintain continuity when user is manually resizing an event.
// Returns an array of DOM elements for the event.
function c(a,b,c){
// actually render the event. `true` for appending element to container.
// Recieve the intermediate "segment" data structures.
var e=d([a],!0,// append event elements
!1),f=[];
// Adjust certain elements' top coordinates
return xa(e,function(a,d){a.row===b&&d.css("top",c),f.push(d[0])}),f}
// Render events onto the calendar. Only responsible for the VISUAL aspect.
// Not responsible for attaching handlers or calling callbacks.
// Set `doAppend` to `true` for rendering elements without clearing the existing container.
// Set `doRowHeights` to allow setting the height of each row, to compensate for vertical event overflow.
function d(b,c,d){
// where the DOM nodes will eventually end up
var f,g,j=T(),m=c?a("<div/>"):j,n=e(b);
// calculate the desired `left` and `width` properties on each segment object
// build the HTML string. relies on `left` property
// render the HTML. innerHTML is considerably faster than jQuery's .html()
// retrieve the individual elements
// if we were appending, and thus using a temporary container,
// re-attach elements to the real container.
// assigns each element to `segment.event`, after filtering them through user callbacks
// Calculate the left and right padding+margin for each element.
// We need this for setting each element's desired outer width, because of the W3C box model.
// It's important we do this in a separate pass from acually setting the width on the DOM elements
// because alternating reading/writing dimensions causes reflow for every iteration.
// Set the width of each element
// Grab each element's outerHeight (setVerticals uses this).
// To get an accurate reading, it's important to have each element's width explicitly set already.
// Set the top coordinate on each element (requires segment.outerHeight)
return h(n),f=i(n),m[0].innerHTML=f,g=m.children(),c&&j.append(g),k(n,g),xa(n,function(a,b){a.hsides=t(b,!0)}),xa(n,function(a,b){b.width(Math.max(0,a.outerWidth-a.hsides))}),xa(n,function(a,b){a.outerHeight=b.outerHeight(!0)}),l(n,d),n}
// Generate an array of "segments" for all events.
function e(a){var b,c,d=x.getResources,e=[];if("undefined"==typeof d)for(b=0;b<a.length;b++)c=g(a[b]),e.push.apply(e,c);else for(b=0;b<d().length;b++)for(var h=f(d()[b],a),i=0;i<h.length;i++)c=g(h[i],b),e.push.apply(e,c);return e}function f(b,c){for(var d=[],e=function(c){return c.resources&&a.grep(c.resources,function(a){return a==b.id}).length},f=0;f<c.length;f++)e(c[f])&&d.push(c[f]);return d}
// Generate an array of segments for a single event.
// A "segment" is the same data structure that View.rangeToSegments produces,
// with the addition of the `event` property being set to reference the original event.
function g(a,b){for(var c=Y(a.start,da(a)),d=0;d<c.length;d++)"undefined"!=typeof b&&(c[d].leftCol=b,c[d].rightCol=b),c[d].event=a;return c}
// Sets the `left` and `outerWidth` property of each segment.
// These values are the desired dimensions for the eventual DOM elements.
function h(a){for(var b=y("isRTL"),c=0;c<a.length;c++){var d=a[c],e=(b?d.isEnd:d.isStart)?R:P,f=(b?d.isStart:d.isEnd)?S:Q,g=e(d.leftCol),h=f(d.rightCol);d.left=g,d.outerWidth=h-g}}
// Build a concatenated HTML string for an array of segments
function i(a){for(var b="",c=0;c<a.length;c++)b+=j(a[c]);return b}
// Build an HTML string for a single segment.
// Relies on the following properties:
// - `segment.event` (from `buildSegmentsForEvent`)
// - `segment.left` (from `calculateHorizontals`)
function j(a){var b="",c=y("isRTL"),d=a.event,e=d.url,f=["fc-event","fc-event-hori"];A(d)&&f.push("fc-event-draggable"),a.isStart&&f.push("fc-event-start"),a.isEnd&&f.push("fc-event-end"),
// use the event's configured classNames
// guaranteed to be an array via `buildEvent`
f=f.concat(d.className),d.source&&(
// use the event's source's classNames, if specified
f=f.concat(d.source.className||[]));
// generate a semicolon delimited CSS string for any of the "skin" properties
// of the event object (`backgroundColor`, `borderColor` and such)
var g=J(d,y);
// TODO:
// When these elements are initially rendered, they will be briefly visibile on the screen,
// even though their widths/heights are not set.
// SOLUTION: initially set them as visibility:hidden ?
return b+=e?"<a href='"+F(e)+"'":"<div",b+=" class='"+f.join(" ")+"' style='position:absolute;left:"+a.left+"px;"+g+"'><div class='fc-event-inner'>",!d.allDay&&a.isStart&&(b+="<span class='fc-event-time'>"+F(x.getEventTimeText(d))+"</span>"),b+="<span class='fc-event-title'>"+F(d.title||"")+"</span></div>",d.allDay&&a.isEnd&&B(d)&&(b+="<div class='ui-resizable-handle ui-resizable-"+(c?"w":"e")+"'>&nbsp;&nbsp;&nbsp;</div>"),b+="</"+(e?"a":"div")+">"}
// Associate each segment (an object) with an element (a jQuery object),
// by setting each `segment.element`.
// Run each element through the `eventRender` filter, which allows developers to
// modify an existing element, supply a new one, or cancel rendering.
function k(b,c){for(var d=0;d<b.length;d++){var e=b[d],f=e.event,g=c.eq(d),h=z("eventRender",f,f,g);h===!1?
// if `false`, remove the event from the DOM and don't assign it to `segment.event`
g.remove():(h&&h!==!0&&(
// the trigger returned a new element, but not `true` (which means keep the existing element)
// re-assign the important CSS dimension properties that were already assigned in `buildHTMLForSegment`
h=a(h).css({position:"absolute",left:e.left}),g.replaceWith(h),g=h),e.element=g)}}/* Top-coordinate Methods
	-------------------------------------------------------------------------------------------------*/
// Sets the "top" CSS property for each element.
// If `doRowHeights` is `true`, also sets each row's first cell to an explicit height,
// so that if elements vertically overflow, the cell expands vertically to compensate.
function l(a,b){var c,d=m(a),e=r(),f=[];
// Set each row's height by setting height of first inner div
if(b)for(c=0;c<e.length;c++)e[c].height(d[c]);
// Get each row's top, relative to the views's origin.
// Important to do this after setting each row's height.
for(c=0;c<e.length;c++)f.push(e[c].position().top);
// Set each segment element's CSS "top" property.
// Each segment object has a "top" property, which is relative to the row's top, but...
xa(a,function(a,b){b.css("top",f[a.row]+a.top)})}
// Calculate the "top" coordinate for each segment, relative to the "top" of the row.
// Also, return an array that contains the "content" height for each row
// (the height displaced by the vertically stacked events in the row).
// Requires segments to have their `outerHeight` property already set.
function m(a){for(var b,c=M(),d=N(),e=[],f=n(a),g=0;g<c;g++){var h=f[g],i=[];for(b=0;b<d;b++)i.push(0);
// loop through every segment
for(var j=0;j<h.length;j++){var k=h[j];
// adjust the columns to account for the segment's height
for(
// find the segment's top coordinate by looking at the max height
// of all the columns the segment will be in.
k.top=D(i.slice(k.leftCol,k.rightCol+1)),b=k.leftCol;b<=k.rightCol;b++)i[b]=k.top+k.outerHeight}
// the tallest column in the row should be the "content height"
e.push(D(i))}return e}
// Build an array of segment arrays, each representing the segments that will
// be in a row of the grid, sorted by which event should be closest to the top.
function n(a){var b,c,d,e=M(),f=[];
// group segments by row
for(b=0;b<a.length;b++)c=a[b],d=c.row,c.element&&(// was rendered?
f[d]?
// already other segments. append to array
f[d].push(c):
// first segment in row. create new array
f[d]=[c]);
// sort each row
for(d=0;d<e;d++)f[d]=o(f[d]||[]);return f}
// Sort an array of segments according to which segment should appear closest to the top
function o(a){
// flatten it
for(var b=[],c=p(a),d=0;d<c.length;d++)b.push.apply(b,c[d]);return b}
// Take an array of segments, which are all assumed to be in the same row,
// and sort into subrows.
function p(a){
// Give preference to elements with certain criteria, so they have
// a chance to be closer to the top.
a.sort(ya);for(var b=[],c=0;c<a.length;c++){
// loop through subrows, starting with the topmost, until the segment
// doesn't collide with other segments.
for(var d=a[c],e=0;e<b.length&&wa(d,b[e]);e++);
// `j` now holds the desired subrow index
b[e]?b[e].push(d):b[e]=[d]}return b}
// Return an array of jQuery objects for the placeholder content containers of each row.
// The content containers don't actually contain anything, but their dimensions should match
// the events that are overlaid on top.
function r(){var a,b=M(),c=[];for(a=0;a<b;a++)c[a]=O(a).find("div.fc-day-content > div");return c}/* Mouse Handlers
	---------------------------------------------------------------------------------------------------*/
// TODO: better documentation!
function s(a,b){var c=T();xa(a,function(a,c,d){var e=a.event;e._id===b?u(e,c,a):c[0]._fci=d}),q(c,a,u)}function u(a,b,c){A(a)&&x.draggableDayEvent(a,b,c),a.allDay&&c.isEnd&&// only allow resizing on the final segment for an event
B(a)&&x.resizableDayEvent(a,b,c),
// attach all other handlers.
// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
E(a,b)}function v(a,b){var c,d,e=X();b.draggable({delay:50,opacity:y("dragOpacity"),revertDuration:y("dragRevertDuration"),start:function(f,g){z("eventDragStart",b[0],a,f,g),I(a,b),e.start(function(e,f,g,h){if(b.draggable("option","revert",!e||!g&&!h),V(),e){var i=Z(f),j=Z(e);c=j.diff(i,"days"),d=a.start.clone().add(c,"days"),U(d,da(a).add(c,"days"))}else c=0},f,"drag")},stop:function(f,g){e.stop(),V(),z("eventDragStop",b[0],a,f,g),c?K(b[0],a,d,f,g):(b.css("filter",""),// clear IE opacity side-effects
G(a,b))}})}function w(b,d,e){var f=y("isRTL"),g=f?"w":"e",h=d.find(".ui-resizable-"+g),i=!1;
// TODO: look into using jquery-ui mouse widget for this stuff
H(d),// prevent native <a> selection for IE
d.mousedown(function(a){// prevent native <a> selection for others
a.preventDefault()}).click(function(a){i&&(a.preventDefault(),// prevent link from being visited (only method that worked in IE6)
a.stopImmediatePropagation())}),h.mousedown(function(f){function h(c){z("eventResizeStop",d[0],b,c,{}),// {} is dummy jqui event
a("body").css("cursor",""),m.stop(),V(),j&&L(d[0],b,k,c,{}),
// otherwise, the drag handler already restored the old events
setTimeout(function(){// make this happen after the element's click event
i=!1},0)}if(1==f.which){i=!0;var j,k,l,m=X(),n=d.css("top"),o=a.extend({},b),p=ba(aa(b.start));W(),a("body").css("cursor",g+"-resize").one("mouseup",h),z("eventResizeStart",d[0],b,f,{}),// {} is dummy jqui event
m.start(function(d,f){if(d){var h=$(f),i=$(d);// assumed to already have a stripped time
if(
// don't let resizing move earlier than start date cell
i=Math.max(i,p),j=_(i)-_(h),k=da(b).add(j,"days"),j){o.end=k;var m=l;l=c(o,e.row,n),l=a(l),// turn array into a jQuery object
l.find("*").css("cursor",g+"-resize"),m&&m.remove(),I(b)}else l&&(G(b),l.remove(),l=null);V(),U(// coordinate grid already rebuilt with hoverListener.start()
b.start,k)}},f)}})}var x=this;
// exports
x.renderDayEvents=b,x.draggableDayEvent=v,// made public so that subclasses can override
x.resizableDayEvent=w;// "
// imports
var y=x.opt,z=x.trigger,A=x.isEventDraggable,B=x.isEventResizable,C=x.reportEventElement,E=x.eventElementHandlers,G=x.showEvents,I=x.hideEvents,K=x.eventDrop,L=x.eventResize,M=x.getRowCnt,N=x.getColCnt,O=x.allDayRow,P=x.colLeft,Q=x.colRight,R=x.colContentLeft,S=x.colContentRight,T=x.getDaySegmentContainer,U=x.renderDayOverlay,V=x.clearOverlays,W=x.clearSelection,X=x.getHoverListener,Y=x.rangeToSegments,Z=x.cellToDate,$=x.cellToCellOffset,_=x.cellOffsetToDayOffset,aa=x.dateToDayOffset,ba=x.dayOffsetToCellOffset,ca=x.calendar,da=ca.getEventEnd}/* Generalized Segment Utilities
-------------------------------------------------------------------------------------------------*/
function wa(a,b){for(var c=0;c<b.length;c++){var d=b[c];if(d.leftCol<=a.rightCol&&d.rightCol>=a.leftCol)return!0}return!1}function xa(a,b){// TODO: use in AgendaView?
for(var c=0;c<a.length;c++){var d=a[c],e=d.element;e&&b(d,e,c)}}
// A cmp function for determining which segments should appear higher up
function ya(a,b){// put wider events first
// if tie, put all-day events first (booleans cast to 0/1)
// if a tie, sort by event start date
return b.rightCol-b.leftCol-(a.rightCol-a.leftCol)||b.event.allDay-a.event.allDay||a.event.start-b.event.start||(a.event.title||"").localeCompare(b.event.title)}
//BUG: unselect needs to be triggered when events are dragged+dropped
function za(){function b(b){var c=j("unselectCancel");c&&a(b.target).parents(c).length||d(b)}function c(a,b){d(),a=i.moment(a),b=b?i.moment(b):l(a),m(a,b),e(a,b)}
// TODO: better date normalization. see notes in automated test
function d(a){o&&(o=!1,n(),k("unselect",null,a))}function e(a,b,c){o=!0,k("select",null,a,b,c)}function f(b){// not really a generic manager method, oh well
var c=h.cellToDate,f=h.getIsCellAllDay,g=h.getHoverListener(),i=h.reportDayClick;// this is hacky and sort of weird
if(1==b.which&&j("selectable")){// which==1 means left mouse button
d(b);var k;g.start(function(a,b){// TODO: maybe put cellToDate/getIsCellAllDay info in cell
n(),a&&f(a)?(k=[c(b),c(a)].sort(C),m(k[0],k[1].clone().add(1,"days"))):k=null},b),a(document).one("mouseup",function(a){g.stop(),k&&(+k[0]==+k[1]&&i(k[0],a),e(k[0],k[1].clone().add(1,"days"),// make exclusive
a))})}}function g(){a(document).off("mousedown",b)}var h=this;
// exports
h.select=c,h.unselect=d,h.reportSelection=e,h.daySelectionMousedown=f,h.selectionManagerDestroy=g;
// imports
var i=h.calendar,j=h.opt,k=h.trigger,l=h.defaultSelectionEnd,m=h.renderSelection,n=h.clearSelection,o=!1;
// unselectAuto
j("selectable")&&j("unselectAuto")&&a(document).on("mousedown",b)}function Aa(){function b(b,c){var d=f.shift();return d||(d=a("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>")),d[0].parentNode!=c[0]&&d.appendTo(c),e.push(d.css(b).show()),d}function c(){for(var a;a=e.shift();)f.push(a.hide().unbind())}var d=this;
// exports
d.renderOverlay=b,d.clearOverlays=c;
// locals
var e=[],f=[]}function Ba(a){var b,c,d=this;d.build=function(){b=[],c=[],a(b,c)},d.cell=function(a,d){var e,f=b.length,g=c.length,h=-1,i=-1;for(e=0;e<f;e++)if(d>=b[e][0]&&d<b[e][1]){h=e;break}for(e=0;e<g;e++)if(a>=c[e][0]&&a<c[e][1]){i=e;break}return h>=0&&i>=0?{row:h,col:i}:null},d.rect=function(a,d,e,f,g){// row1,col1 is inclusive
var h=g.offset();return{top:b[a][0]-h.top,left:c[d][0]-h.left,width:c[f][1]-c[d][0],height:b[e][1]-b[a][0]}}}function Ca(b){function c(a){Da(a);// see below
var c=b.cell(a.pageX,a.pageY);(Boolean(c)!==Boolean(g)||c&&(c.row!=g.row||c.col!=g.col))&&(c?(f||(f=c),e(c,f,c.row-f.row,c.col-f.col)):e(c,f),g=c)}var d,e,f,g,h=this;h.start=function(h,i,j){e=h,f=g=null,b.build(),c(i),d=j||"mousemove",a(document).bind(d,c)},h.stop=function(){return a(document).unbind(d,c),g}}
// this fix was only necessary for jQuery UI 1.8.16 (and jQuery 1.7 or 1.7.1)
// upgrading to jQuery UI 1.8.17 (and using either jQuery 1.7 or 1.7.1) fixed the problem
// but keep this in here for 1.8.16 users
// and maybe remove it down the line
function Da(a){// for issue 1168
void 0===a.pageX&&(a.pageX=a.originalEvent.pageX,a.pageY=a.originalEvent.pageY)}function Ea(a){function b(b){return d[b]=d[b]||a(b)}var c=this,d={},e={},f={};c.left=function(a){return e[a]=void 0===e[a]?b(a).position().left:e[a]},c.right=function(a){return f[a]=void 0===f[a]?c.left(a)+b(a).width():f[a]},c.clear=function(){d={},e={},f={}}}var Fa={lang:"en",defaultTimedEventDuration:"02:00:00",defaultAllDayEventDuration:{days:1},forceEventDuration:!1,nextDayThreshold:"09:00:00",// 9am
// display
defaultView:"month",aspectRatio:1.35,header:{left:"title",center:"",right:"today prev,next"},weekends:!0,weekNumbers:!1,weekNumberTitle:"W",weekNumberCalculation:"local",
//editable: false,
// event ajax
lazyFetching:!0,startParam:"start",endParam:"end",timezoneParam:"timezone",timezone:!1,
//allDayDefault: undefined,
// time formats
titleFormat:{month:"MMMM YYYY",// like "September 1986". each language will override this
week:"ll",// like "Sep 4 1986"
day:"LL"},columnFormat:{month:"ddd",// like "Sat"
week:d,day:"dddd"},timeFormat:{// for event elements
"default":c},displayEventEnd:{month:!1,basicWeek:!1,"default":!0},
// locale
isRTL:!1,defaultButtonText:{prev:"prev",next:"next",prevYear:"prev year",nextYear:"next year",today:"today",month:"month",week:"week",day:"day"},buttonIcons:{prev:"left-single-arrow",next:"right-single-arrow",prevYear:"left-double-arrow",nextYear:"right-double-arrow"},
// jquery-ui theming
theme:!1,themeButtonIcons:{prev:"circle-triangle-w",next:"circle-triangle-e",prevYear:"seek-prev",nextYear:"seek-next"},
//selectable: false,
unselectAuto:!0,dropAccept:"*",handleWindowResize:!0,windowResizeDelay:200},Ga={en:{columnFormat:{week:"ddd M/D"}}},Ha={header:{left:"next,prev today",center:"",right:"title"},buttonIcons:{prev:"right-single-arrow",next:"left-single-arrow",prevYear:"right-double-arrow",nextYear:"left-double-arrow"},themeButtonIcons:{prev:"circle-triangle-e",next:"circle-triangle-w",nextYear:"seek-prev",prevYear:"seek-next"}},Ia=a.fullCalendar={version:"2.0.3"},Ja=Ia.views={};a.fn.fullCalendar=function(b){var c=Array.prototype.slice.call(arguments,1),d=this;// what this function will return (this jQuery object by default)
return this.each(function(e,f){// loop each DOM element involved
var g,i=a(f),j=i.data("fullCalendar");// the returned value of this single method call
// a method call
"string"==typeof b?j&&a.isFunction(j[b])&&(g=j[b].apply(j,c),e||(d=g),"destroy"===b&&// for the destroy method, must remove Calendar object data
i.removeData("fullCalendar")):j||(// don't initialize twice
j=new h(i,b),i.data("fullCalendar",j),j.render())}),d},
//var langOptionHash = {}; // initialized in defaults.js
Ia.langs=Ga,// expose
// Initialize jQuery UI Datepicker translations while using some of the translations
// for our own purposes. Will set this as the default language for datepicker.
// Called from a translation file.
Ia.datepickerLang=function(b,c,d){var e=Ga[b];
// initialize FullCalendar's lang hash for this language
e||(e=Ga[b]={}),
// merge certain Datepicker options into FullCalendar's options
f(e,{isRTL:d.isRTL,weekNumberTitle:d.weekHeader,titleFormat:{month:d.showMonthAfterYear?"YYYY["+d.yearSuffix+"] MMMM":"MMMM YYYY["+d.yearSuffix+"]"},defaultButtonText:{
// the translations sometimes wrongly contain HTML entities
prev:G(d.prevText),next:G(d.nextText),today:G(d.currentText)}}),
// is jQuery UI Datepicker is on the page?
a.datepicker&&(
// Register the language data.
// FullCalendar and MomentJS use language codes like "pt-br" but Datepicker
// does it like "pt-BR" or if it doesn't have the language, maybe just "pt".
// Make an alias so the language can be referenced either way.
a.datepicker.regional[c]=a.datepicker.regional[b]=// alias
d,
// Alias 'en' to the default language data. Do this every time.
a.datepicker.regional.en=a.datepicker.regional[""],
// Set as Datepicker's global defaults.
a.datepicker.setDefaults(d))},
// Sets FullCalendar-specific translations. Also sets the language as the global default.
// Called from a translation file.
Ia.lang=function(a,b){var c;b&&(c=Ga[a],
// initialize the hash for this language
c||(c=Ga[a]={}),f(c,b||{})),
// set it as the default language for FullCalendar
Fa.lang=a},Ia.sourceNormalizers=[],Ia.sourceFetchers=[];var Ka={dataType:"json",cache:!1},La=1;Ia.applyAll=K;/* Date
-----------------------------------------------------------------------------*/
var Ma=["sun","mon","tue","wed","thu","fri","sat"],Na=/^\s*\d{4}-\d\d$/,Oa=/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When gived an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
Ia.moment=function(){return M(arguments)},
// Sames as fc.moment, but forces the resulting moment to be in the UTC timezone.
Ia.moment.utc=function(){var a=M(arguments,!0);
// Force it into UTC because makeMoment doesn't guarantee it.
// don't give ambiguously-timed moments a UTC zone
return a.hasTime()&&a.utc(),a},
// Same as fc.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
Ia.moment.parseZone=function(){return M(arguments,!0,!0)},
// Chain the prototype to Moment's
N.prototype=m(b.fn),
// We need this because Moment's implementation won't create an FCMoment,
// nor will it copy over the ambig flags.
N.prototype.clone=function(){return M([this])},
// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
N.prototype.time=function(a){if(null==a)// getter
return b.duration({hours:this.hours(),minutes:this.minutes(),seconds:this.seconds(),milliseconds:this.milliseconds()});// setter
delete this._ambigTime,// mark that the moment now has a time
b.isDuration(a)||b.isMoment(a)||(a=b.duration(a));
// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
// Only for Duration times, not Moment times.
var c=0;
// We need to set the individual fields.
// Can't use startOf('day') then add duration. In case of DST at start of day.
return b.isDuration(a)&&(c=24*Math.floor(a.asDays())),this.hours(c+a.hours()).minutes(a.minutes()).seconds(a.seconds()).milliseconds(a.milliseconds())},
// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
N.prototype.stripTime=function(){var a=this.toArray();// if ambiguous time, also ambiguous timezone offset
// year,month,date,hours,minutes,seconds as an array
// set the internal UTC flag
// call the original method, because we don't want to affect _ambigZone
// Mark the time as ambiguous. This needs to happen after the .utc() call, which calls .zone(), which
// clears all ambig flags. Same concept with the .year/month/date calls in the case of moment-timezone.
return b.fn.utc.call(this),this.year(a[0]).month(a[1]).date(a[2]).hours(0).minutes(0).seconds(0).milliseconds(0),this._ambigTime=!0,this._ambigZone=!0,this},
// Returns if the moment has a non-ambiguous time (boolean)
N.prototype.hasTime=function(){return!this._ambigTime},
// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
N.prototype.stripZone=function(){var a=this.toArray(),c=this._ambigTime;// set the internal UTC flag
// the above call to .utc()/.zone() unfortunately clears the ambig flags, so reassign
// Mark the zone as ambiguous. This needs to happen after the .utc() call, which calls .zone(), which
// clears all ambig flags. Same concept with the .year/month/date calls in the case of moment-timezone.
return b.fn.utc.call(this),this.year(a[0]).month(a[1]).date(a[2]).hours(a[3]).minutes(a[4]).seconds(a[5]).milliseconds(a[6]),c&&(this._ambigTime=!0),this._ambigZone=!0,this},
// Returns of the moment has a non-ambiguous timezone offset (boolean)
N.prototype.hasZone=function(){return!this._ambigZone},
// this method implicitly marks a zone
N.prototype.zone=function(a){
// FYI, the delete statements need to be before the .zone() call or else chaos ensues
// for reasons I don't understand. 
return null!=a&&(delete this._ambigTime,delete this._ambigZone),b.fn.zone.apply(this,arguments)},
// this method implicitly marks a zone
N.prototype.local=function(){var a=this.toArray(),c=this._ambigZone;
// will happen anyway via .local()/.zone(), but don't want to rely on internal implementation
// If the moment was ambiguously zoned, the date fields were stored as UTC.
// We want to preserve these, but in local time.
return delete this._ambigTime,delete this._ambigZone,b.fn.local.apply(this,arguments),c&&this.year(a[0]).month(a[1]).date(a[2]).hours(a[3]).minutes(a[4]).seconds(a[5]).milliseconds(a[6]),this},
// this method implicitly marks a zone
N.prototype.utc=function(){
// will happen anyway via .local()/.zone(), but don't want to rely on internal implementation
return delete this._ambigTime,delete this._ambigZone,b.fn.utc.apply(this,arguments)},
// Formatting
// -------------------------------------------------------------------------------------------------
N.prototype.format=function(){return arguments[0]?Q(this,arguments[0]):this._ambigTime?P(this,"YYYY-MM-DD"):this._ambigZone?P(this,"YYYY-MM-DD[T]HH:mm:ss"):P(this)},N.prototype.toISOString=function(){return this._ambigTime?P(this,"YYYY-MM-DD"):this._ambigZone?P(this,"YYYY-MM-DD[T]HH:mm:ss"):b.fn.toISOString.apply(this,arguments)},
// Querying
// -------------------------------------------------------------------------------------------------
// Is the moment within the specified range? `end` is exclusive.
N.prototype.isWithin=function(a,b){var c=O([this,a,b]);return c[0]>=c[1]&&c[0]<c[2]},
// Make these query methods work with ambiguous moments
a.each(["isBefore","isAfter","isSame"],function(a,c){N.prototype[c]=function(a,d){var e=O([this,a]);return b.fn[c].call(e[0],e[1],d)}});
// addition formatting tokens we want recognized
var Pa={t:function(a){// "a" or "p"
return P(a,"a").charAt(0)},T:function(a){// "A" or "P"
return P(a,"A").charAt(0)}};Ia.formatRange=T;var Qa={Y:"year",M:"month",D:"day",// day of month
d:"day",// day of week
// prevents a separator between anything time-related...
A:"second",// AM/PM
a:"second",// am/pm
T:"second",// A/P
t:"second",// a/p
H:"second",// hour (24)
h:"second",// hour (12)
m:"second",// minute
s:"second"},Ra={};Ja.month=Y,Ja.basicWeek=Z,Ja.basicDay=$,e({weekMode:"fixed"}),Ja.agendaWeek=ba,Ja.agendaDay=ca,e({allDaySlot:!0,allDayText:"all-day",scrollTime:"06:00:00",slotDuration:"00:30:00",axisFormat:da,timeFormat:{agenda:ea},dragOpacity:{agenda:.5},minTime:"00:00:00",maxTime:"24:00:00",slotEventOverlap:!0}),Ja.resourceDay=ra,e({allDaySlot:!0,allDayText:"all-day",scrollTime:"06:00:00",slotDuration:"00:30:00",axisFormat:da,timeFormat:{resource:ea},dragOpacity:{resource:.5},minTime:"00:00:00",maxTime:"24:00:00",slotEventOverlap:!0})});